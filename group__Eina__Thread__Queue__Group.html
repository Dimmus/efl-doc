<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Thread Queue Group</title>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-110876574-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-110876574-1');
  </script>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link rel="icon" href="favicon.png" type="image/x-icon">
  <link rel="shortcut icon" href="favicon.png" type="image/x-icon">
  <link rel="icon" href="favicon.png" type="image/ico">
  <link rel="shortcut icon" href="favicon.png" type="image/ico">
  <link rel="stylesheet" type="text/css" href="e.css">
</head>
<body>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Thread Queue Group<div class="ingroups"><a class="el" href="group__Eina.html">Eina</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>These functions provide simple zero-copy message queues for threads.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__Eina__Thread__Queue__Msg.html">_Eina_Thread_Queue_Msg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__Eina__Thread__Queue__Msg__Sub.html">_Eina_Thread_Queue_Msg_Sub</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga414a1a16533bf9ba8bdf14ffb61c2ed9"><td class="memItemLeft" align="right" valign="top">typedef struct _Eina_Thread_Queue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a></td></tr>
<tr class="memdesc:ga414a1a16533bf9ba8bdf14ffb61c2ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a uni-directional zero-copy thread message queue specifically designed with the idea of sending large volumes of messages with no copies from one thread to another (or from/to the mainloop).  <a href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">More...</a><br /></td></tr>
<tr class="separator:ga414a1a16533bf9ba8bdf14ffb61c2ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga691263b2be42e2b5671448f275687eb5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__Eina__Thread__Queue__Msg.html">_Eina_Thread_Queue_Msg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga691263b2be42e2b5671448f275687eb5">Eina_Thread_Queue_Msg</a></td></tr>
<tr class="memdesc:ga691263b2be42e2b5671448f275687eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the minimal header of every message to be put into an Eina Thread Queue.  <a href="group__Eina__Thread__Queue__Group.html#ga691263b2be42e2b5671448f275687eb5">More...</a><br /></td></tr>
<tr class="separator:ga691263b2be42e2b5671448f275687eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f77f4fb207e88cc9455ef661d3b9f12"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__Eina__Thread__Queue__Msg__Sub.html">_Eina_Thread_Queue_Msg_Sub</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga6f77f4fb207e88cc9455ef661d3b9f12">Eina_Thread_Queue_Msg_Sub</a></td></tr>
<tr class="memdesc:ga6f77f4fb207e88cc9455ef661d3b9f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special message type for Eina Thread Queues that have child queues.  <a href="group__Eina__Thread__Queue__Group.html#ga6f77f4fb207e88cc9455ef661d3b9f12">More...</a><br /></td></tr>
<tr class="separator:ga6f77f4fb207e88cc9455ef661d3b9f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7454c386d4564e80f9fd09fec6d81d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga7454c386d4564e80f9fd09fec6d81d57">eina_thread_queue_new</a> (void)</td></tr>
<tr class="memdesc:ga7454c386d4564e80f9fd09fec6d81d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread queue.  <a href="group__Eina__Thread__Queue__Group.html#ga7454c386d4564e80f9fd09fec6d81d57">More...</a><br /></td></tr>
<tr class="separator:ga7454c386d4564e80f9fd09fec6d81d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dc50362ecdf88dc8f49d389d75cddfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga2dc50362ecdf88dc8f49d389d75cddfc">eina_thread_queue_free</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq)</td></tr>
<tr class="memdesc:ga2dc50362ecdf88dc8f49d389d75cddfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a thread queue.  <a href="group__Eina__Thread__Queue__Group.html#ga2dc50362ecdf88dc8f49d389d75cddfc">More...</a><br /></td></tr>
<tr class="separator:ga2dc50362ecdf88dc8f49d389d75cddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9fe44c062c078ea527bf7bece6ff56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#gaab9fe44c062c078ea527bf7bece6ff56">eina_thread_queue_send</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, int size, void **allocref)</td></tr>
<tr class="memdesc:gaab9fe44c062c078ea527bf7bece6ff56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a message to send down a thread queue.  <a href="group__Eina__Thread__Queue__Group.html#gaab9fe44c062c078ea527bf7bece6ff56">More...</a><br /></td></tr>
<tr class="separator:gaab9fe44c062c078ea527bf7bece6ff56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga608f2e364a412702b66dfab1e0a9cb49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga608f2e364a412702b66dfab1e0a9cb49">eina_thread_queue_send_done</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, void *allocref)</td></tr>
<tr class="memdesc:ga608f2e364a412702b66dfab1e0a9cb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes sending the allocated message.  <a href="group__Eina__Thread__Queue__Group.html#ga608f2e364a412702b66dfab1e0a9cb49">More...</a><br /></td></tr>
<tr class="separator:ga608f2e364a412702b66dfab1e0a9cb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58fad2272133610d3b2b7ecbfadd961e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga58fad2272133610d3b2b7ecbfadd961e">eina_thread_queue_wait</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, void **allocref)</td></tr>
<tr class="memdesc:ga58fad2272133610d3b2b7ecbfadd961e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches a message from a thread queue.  <a href="group__Eina__Thread__Queue__Group.html#ga58fad2272133610d3b2b7ecbfadd961e">More...</a><br /></td></tr>
<tr class="separator:ga58fad2272133610d3b2b7ecbfadd961e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee572830d2decde1ab4563af506f048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga1ee572830d2decde1ab4563af506f048">eina_thread_queue_wait_done</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, void *allocref)</td></tr>
<tr class="memdesc:ga1ee572830d2decde1ab4563af506f048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes fetching a message from a thread queue.  <a href="group__Eina__Thread__Queue__Group.html#ga1ee572830d2decde1ab4563af506f048">More...</a><br /></td></tr>
<tr class="separator:ga1ee572830d2decde1ab4563af506f048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4143fef115f6d28a4dac49257ac27d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga4143fef115f6d28a4dac49257ac27d91">eina_thread_queue_poll</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, void **allocref)</td></tr>
<tr class="memdesc:ga4143fef115f6d28a4dac49257ac27d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches a message from a thread queue, but return immediately if there is none with NULL.  <a href="group__Eina__Thread__Queue__Group.html#ga4143fef115f6d28a4dac49257ac27d91">More...</a><br /></td></tr>
<tr class="separator:ga4143fef115f6d28a4dac49257ac27d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31bb3d31c852d7eb27c33995cc9d085e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga31bb3d31c852d7eb27c33995cc9d085e">eina_thread_queue_pending_get</a> (const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq)</td></tr>
<tr class="memdesc:ga31bb3d31c852d7eb27c33995cc9d085e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of messages on a queue as yet unfetched.  <a href="group__Eina__Thread__Queue__Group.html#ga31bb3d31c852d7eb27c33995cc9d085e">More...</a><br /></td></tr>
<tr class="separator:ga31bb3d31c852d7eb27c33995cc9d085e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd71fbfc538c180554bec7ac26cdec4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#gadd71fbfc538c180554bec7ac26cdec4c">eina_thread_queue_parent_set</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq_parent)</td></tr>
<tr class="memdesc:gadd71fbfc538c180554bec7ac26cdec4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parent of a thread queue (make this one a child).  <a href="group__Eina__Thread__Queue__Group.html#gadd71fbfc538c180554bec7ac26cdec4c">More...</a><br /></td></tr>
<tr class="separator:gadd71fbfc538c180554bec7ac26cdec4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbac54bb75987f661515a789b434d5fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#gabbac54bb75987f661515a789b434d5fc">eina_thread_queue_parent_get</a> (const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq)</td></tr>
<tr class="memdesc:gabbac54bb75987f661515a789b434d5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent of a thread queue.  <a href="group__Eina__Thread__Queue__Group.html#gabbac54bb75987f661515a789b434d5fc">More...</a><br /></td></tr>
<tr class="separator:gabbac54bb75987f661515a789b434d5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga388e7fbe95fd962037619d8b5aebaaee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga388e7fbe95fd962037619d8b5aebaaee">eina_thread_queue_fd_set</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, int fd)</td></tr>
<tr class="memdesc:ga388e7fbe95fd962037619d8b5aebaaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a file descriptor to write a byte to on a message send.  <a href="group__Eina__Thread__Queue__Group.html#ga388e7fbe95fd962037619d8b5aebaaee">More...</a><br /></td></tr>
<tr class="separator:ga388e7fbe95fd962037619d8b5aebaaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga040d162dc13985cef40d27cd77386975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga040d162dc13985cef40d27cd77386975">eina_thread_queue_fd_get</a> (const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq)</td></tr>
<tr class="memdesc:ga040d162dc13985cef40d27cd77386975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file descriptor written to on message sends.  <a href="group__Eina__Thread__Queue__Group.html#ga040d162dc13985cef40d27cd77386975">More...</a><br /></td></tr>
<tr class="separator:ga040d162dc13985cef40d27cd77386975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These functions provide simple zero-copy message queues for threads. </p>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga414a1a16533bf9ba8bdf14ffb61c2ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga414a1a16533bf9ba8bdf14ffb61c2ed9">&#9670;&nbsp;</a></span>Eina_Thread_Queue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a uni-directional zero-copy thread message queue specifically designed with the idea of sending large volumes of messages with no copies from one thread to another (or from/to the mainloop). </p>
<p>The idea is that a thread queue is created and then one or more threads send messages in one end and fetch messages off the other end. If you set a parent message queue to 1 or more queues, then this parent will wake up with a sub queue message, indicating which child queue woke up. This can be used to implement the ability to listen to multiple queues at once.</p>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

</div>
</div>
<a id="ga691263b2be42e2b5671448f275687eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga691263b2be42e2b5671448f275687eb5">&#9670;&nbsp;</a></span>Eina_Thread_Queue_Msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga691263b2be42e2b5671448f275687eb5">Eina_Thread_Queue_Msg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the minimal header of every message to be put into an Eina Thread Queue. </p>
<p>Every message has at least this header at the start of the message data, with payload following. You would put this structure as the first struct member of every message type you have, like Eina_Thread_Queue_Msg_Sub does. Messages are always 8 byte aligned within message memory to ensure alignment of all types.</p>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

</div>
</div>
<a id="ga6f77f4fb207e88cc9455ef661d3b9f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f77f4fb207e88cc9455ef661d3b9f12">&#9670;&nbsp;</a></span>Eina_Thread_Queue_Msg_Sub</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga6f77f4fb207e88cc9455ef661d3b9f12">Eina_Thread_Queue_Msg_Sub</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a special message type for Eina Thread Queues that have child queues. </p>
<p>This is the only Message type for a parent message queue and it indicates which child queue was woken up with a new message to read. When this message is retrieved, the caller should then also fetch the message from the indicated child queue too.</p>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7454c386d4564e80f9fd09fec6d81d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7454c386d4564e80f9fd09fec6d81d57">&#9670;&nbsp;</a></span>eina_thread_queue_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a>* eina_thread_queue_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new thread queue. </p>
<dl class="section return"><dt>Returns</dt><dd>A valid new thread queue, or NULL on failure</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga093fddb63d97504084f49dd36df65fd0">eina_semaphore_new()</a>, <a class="el" href="group__Eina__Lock__Group.html#ga5f4b36220ae88623031cb0e9bf5de290">eina_spinlock_new()</a>, and <a class="el" href="group__Eina__File__Group.html#ga24e93be9c5baa3aeab7021b64e290672">ERR</a>.</p>

</div>
</div>
<a id="ga2dc50362ecdf88dc8f49d389d75cddfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dc50362ecdf88dc8f49d389d75cddfc">&#9670;&nbsp;</a></span>eina_thread_queue_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void eina_thread_queue_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a thread queue. </p>
<p>This frees a thread queue. It must no longer be in use by anything waiting on messages or sending them. Any pending messages will be freed without being processed by a listener.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thq</td><td>The thread queue to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga3ed968965c79524a43f6efea20459d49">eina_semaphore_free()</a>, and <a class="el" href="group__Eina__Lock__Group.html#gac2593032eadc7b1e03c0980f2dedb7ca">eina_spinlock_free()</a>.</p>

</div>
</div>
<a id="gaab9fe44c062c078ea527bf7bece6ff56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab9fe44c062c078ea527bf7bece6ff56">&#9670;&nbsp;</a></span>eina_thread_queue_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void* eina_thread_queue_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>allocref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a message to send down a thread queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue to allocate the message on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the message, including standard header </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocref</td><td>A pointer to store a general reference handle for the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the message data to fill in</dd></dl>
<p>This allocates space for a new message on the message queue, but does not actually trigger the send. For that you will need to call <a class="el" href="group__Eina__Thread__Queue__Group.html#ga608f2e364a412702b66dfab1e0a9cb49" title="Finishes sending the allocated message.">eina_thread_queue_send_done()</a> to complete the send and trigger the other side. Every message must at least be a Eina_Thread_Queue_Msg in size and have this structure as the first member (first N bytes) of the message.</p>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga7143ee35b9894e80578753485284256c">eina_spinlock_release()</a>, and <a class="el" href="group__Eina__Lock__Group.html#gaf9556624e5c6db1a66c20615c523efb5">eina_spinlock_take()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__Eina__Thread__Queue__Group.html#ga608f2e364a412702b66dfab1e0a9cb49">eina_thread_queue_send_done()</a>.</p>

</div>
</div>
<a id="ga608f2e364a412702b66dfab1e0a9cb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga608f2e364a412702b66dfab1e0a9cb49">&#9670;&nbsp;</a></span>eina_thread_queue_send_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void eina_thread_queue_send_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes sending the allocated message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue the message was placed on </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">allocref</td><td>The allocref returned by <a class="el" href="group__Eina__Thread__Queue__Group.html#gaab9fe44c062c078ea527bf7bece6ff56" title="Allocates a message to send down a thread queue.">eina_thread_queue_send()</a></td></tr>
  </table>
  </dd>
</dl>
<p>This completes the send and triggers the thread queue to wake up any listeners.</p>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Thread__Queue__Group.html#gaab9fe44c062c078ea527bf7bece6ff56">eina_thread_queue_send()</a>, and <a class="el" href="group__Eina__File__Group.html#ga24e93be9c5baa3aeab7021b64e290672">ERR</a>.</p>

</div>
</div>
<a id="ga58fad2272133610d3b2b7ecbfadd961e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58fad2272133610d3b2b7ecbfadd961e">&#9670;&nbsp;</a></span>eina_thread_queue_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void* eina_thread_queue_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>allocref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches a message from a thread queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue to fetch the message from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocref</td><td>A pointer to store a general reference handle for the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the message data</dd></dl>
<p>This will fetch the next message to read from the thread queue and return a pointer to it. The message is guaranteed to have an initial Eina_Thread_Queue_Msg member that will indicate size of the message as a whole. This function will wait, if no messages are available to read and block until a new message comes in, then return. When the message is finished with, the caller must use <a class="el" href="group__Eina__Thread__Queue__Group.html#ga1ee572830d2decde1ab4563af506f048" title="Finishes fetching a message from a thread queue.">eina_thread_queue_wait_done()</a> to indicate they are done.</p>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga7143ee35b9894e80578753485284256c">eina_spinlock_release()</a>, and <a class="el" href="group__Eina__Lock__Group.html#gaf9556624e5c6db1a66c20615c523efb5">eina_spinlock_take()</a>.</p>

</div>
</div>
<a id="ga1ee572830d2decde1ab4563af506f048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ee572830d2decde1ab4563af506f048">&#9670;&nbsp;</a></span>eina_thread_queue_wait_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void eina_thread_queue_wait_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes fetching a message from a thread queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue the message was fetched from </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">allocref</td><td>The allocref returned by <a class="el" href="group__Eina__Thread__Queue__Group.html#ga58fad2272133610d3b2b7ecbfadd961e" title="Fetches a message from a thread queue.">eina_thread_queue_wait()</a></td></tr>
  </table>
  </dd>
</dl>
<p>This should be used after <a class="el" href="group__Eina__Thread__Queue__Group.html#ga58fad2272133610d3b2b7ecbfadd961e" title="Fetches a message from a thread queue.">eina_thread_queue_wait()</a> or <a class="el" href="group__Eina__Thread__Queue__Group.html#ga4143fef115f6d28a4dac49257ac27d91" title="Fetches a message from a thread queue, but return immediately if there is none with NULL.">eina_thread_queue_poll()</a> to indicate the caller is done with the message.</p>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

</div>
</div>
<a id="ga4143fef115f6d28a4dac49257ac27d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4143fef115f6d28a4dac49257ac27d91">&#9670;&nbsp;</a></span>eina_thread_queue_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void* eina_thread_queue_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>allocref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches a message from a thread queue, but return immediately if there is none with NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue to fetch the message from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocref</td><td>A pointer to store a general reference handle for the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the message data</dd></dl>
<p>This is the same as <a class="el" href="group__Eina__Thread__Queue__Group.html#ga58fad2272133610d3b2b7ecbfadd961e" title="Fetches a message from a thread queue.">eina_thread_queue_wait()</a>, but if no messages are available for reading, it immediately returns NULL to the caller, without waiting for a new message to arrive.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Eina__Thread__Queue__Group.html#ga58fad2272133610d3b2b7ecbfadd961e" title="Fetches a message from a thread queue.">eina_thread_queue_wait()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga7143ee35b9894e80578753485284256c">eina_spinlock_release()</a>, and <a class="el" href="group__Eina__Lock__Group.html#gaf9556624e5c6db1a66c20615c523efb5">eina_spinlock_take()</a>.</p>

</div>
</div>
<a id="ga31bb3d31c852d7eb27c33995cc9d085e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31bb3d31c852d7eb27c33995cc9d085e">&#9670;&nbsp;</a></span>eina_thread_queue_pending_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> int eina_thread_queue_pending_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of messages on a queue as yet unfetched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thq</td><td>The thread queue to query for pending count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of messages waiting to be fetched</dd></dl>
<p>This returns the number of messages waiting to be fetched with <a class="el" href="group__Eina__Thread__Queue__Group.html#ga58fad2272133610d3b2b7ecbfadd961e" title="Fetches a message from a thread queue.">eina_thread_queue_wait()</a> or <a class="el" href="group__Eina__Thread__Queue__Group.html#ga4143fef115f6d28a4dac49257ac27d91" title="Fetches a message from a thread queue, but return immediately if there is none with NULL.">eina_thread_queue_poll()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

</div>
</div>
<a id="gadd71fbfc538c180554bec7ac26cdec4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd71fbfc538c180554bec7ac26cdec4c">&#9670;&nbsp;</a></span>eina_thread_queue_parent_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void eina_thread_queue_parent_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq_parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the parent of a thread queue (make this one a child). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue to alter the parent of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thq_parent</td><td>The new parent to set</td></tr>
  </table>
  </dd>
</dl>
<p>This sets the parent queue where messages will be reported to. This is how you can listen to multiple queues at once - set multiple queues to have the same parent and then just wait on that one parent. This should be done before any messages are read from or written to the queue. To unset a parent, just set the parent to NULL.</p>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

</div>
</div>
<a id="gabbac54bb75987f661515a789b434d5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbac54bb75987f661515a789b434d5fc">&#9670;&nbsp;</a></span>eina_thread_queue_parent_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a>* eina_thread_queue_parent_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the parent of a thread queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thq</td><td>The thread queue to get the parent of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parent thread queue</dd></dl>
<p>This gets the parent set by <a class="el" href="group__Eina__Thread__Queue__Group.html#gabbac54bb75987f661515a789b434d5fc" title="Gets the parent of a thread queue.">eina_thread_queue_parent_get()</a>. If no parent is set, NULL is returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Eina__Thread__Queue__Group.html#gadd71fbfc538c180554bec7ac26cdec4c" title="Sets the parent of a thread queue (make this one a child).">eina_thread_queue_parent_set()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

</div>
</div>
<a id="ga388e7fbe95fd962037619d8b5aebaaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga388e7fbe95fd962037619d8b5aebaaee">&#9670;&nbsp;</a></span>eina_thread_queue_fd_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> void eina_thread_queue_fd_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a file descriptor to write a byte to on a message send. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue to set the file descriptor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>The fd to set, or -1 to unset it</td></tr>
  </table>
  </dd>
</dl>
<p>This sets a file descriptor to write to when a message is written to the thread queue. This can be used to glue a thread queue to something like an Ecore_Pipe that can wake up the mainloop and call a callback whenever data is available on the pipe. The number of bytes available will be the number of messages to fetch from the associated thread queue.</p>
<p>You should set this up before anything writes to or reads from this thread queue.</p>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

</div>
</div>
<a id="ga040d162dc13985cef40d27cd77386975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga040d162dc13985cef40d27cd77386975">&#9670;&nbsp;</a></span>eina_thread_queue_fd_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga6ac08753ba12bc9c7a0390cf67868f4f">EINA_API</a> int eina_thread_queue_fd_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the file descriptor written to on message sends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thq</td><td>The thread queue to get the file descriptor of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file descriptor set (or -1 if none is set).</dd></dl>
<p>This returns the file descriptor set by <a class="el" href="group__Eina__Thread__Queue__Group.html#ga388e7fbe95fd962037619d8b5aebaaee" title="Sets a file descriptor to write a byte to on a message send.">eina_thread_queue_fd_set()</a> and by default returns -1 (no fd set).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Eina__Thread__Queue__Group.html#ga388e7fbe95fd962037619d8b5aebaaee" title="Sets a file descriptor to write a byte to on a message send.">eina_thread_queue_fd_set()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.11 </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="footer">
  <p>
    <span class="version">EFL 1.26.99</span>
    <span class="copyright">Copyright &copy;2000-2022 <a href="http://www.enlightenment.org">enlightenment.org</a></span>
    <span class="generated">Generated @ Sat Oct 29 2022 18:11:21</span>
  </p>
</div>
</body>
</html>
