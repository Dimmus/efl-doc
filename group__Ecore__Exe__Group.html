<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Process Spawning Functions</title>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-110876574-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-110876574-1');
  </script>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link rel="icon" href="favicon.png" type="image/x-icon">
  <link rel="shortcut icon" href="favicon.png" type="image/x-icon">
  <link rel="icon" href="favicon.png" type="image/ico">
  <link rel="shortcut icon" href="favicon.png" type="image/ico">
  <link rel="stylesheet" type="text/css" href="e.css">
</head>
<body>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Process Spawning Functions<div class="ingroups"><a class="el" href="group__Ecore.html">Ecore</a> &raquo; <a class="el" href="group__Ecore__Main__Loop__Group.html">Ecore main loop</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This module is responsible for managing portable processes using Ecore.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__Ecore__Exe__Event__Add.html">_Ecore_Exe_Event_Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition for a structure that stores information of a Process add event.  <a href="struct__Ecore__Exe__Event__Add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__Ecore__Exe__Event__Del.html">_Ecore_Exe_Event_Del</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition for a structure that stores information of a Process exit event.  <a href="struct__Ecore__Exe__Event__Del.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2e582481831ba6241f6304dee1a158ec"><td class="memItemLeft" align="right" valign="top"><a id="ga2e582481831ba6241f6304dee1a158ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga2e582481831ba6241f6304dee1a158ec">ECORE_EXE_PRIORITY_INHERIT</a>&#160;&#160;&#160;9999</td></tr>
<tr class="memdesc:ga2e582481831ba6241f6304dee1a158ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit priority from parent process. <br /></td></tr>
<tr class="separator:ga2e582481831ba6241f6304dee1a158ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa159e067a820abcc4e34c8465514a7ae"><td class="memItemLeft" align="right" valign="top"><a id="gaa159e067a820abcc4e34c8465514a7ae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_ECORE_EXE_EO_CLASS_TYPE</b></td></tr>
<tr class="separator:gaa159e067a820abcc4e34c8465514a7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga13e2029894ee902e9ac52ab492b8742d"><td class="memItemLeft" align="right" valign="top"><a id="ga13e2029894ee902e9ac52ab492b8742d"></a>
typedef enum <a class="el" href="group__Ecore__Exe__Group.html#ga938d59de6a9385e7d98c4b45f809d23f">_Ecore_Exe_Win32_Priority</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Ecore_Exe_Win32_Priority</b></td></tr>
<tr class="separator:ga13e2029894ee902e9ac52ab492b8742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13ecbbae5c3cd4a8cb6b6267cdb984c9"><td class="memItemLeft" align="right" valign="top"><a id="ga13ecbbae5c3cd4a8cb6b6267cdb984c9"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga13ecbbae5c3cd4a8cb6b6267cdb984c9">Ecore_Exe_Cb</a>) (void *data, const <a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga13ecbbae5c3cd4a8cb6b6267cdb984c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback to run with the associated <a class="el" href="structEcore__Exe.html">Ecore_Exe</a>, usually for cleanup purposes. <br /></td></tr>
<tr class="separator:ga13ecbbae5c3cd4a8cb6b6267cdb984c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf37c080c298e92468a3f6972f57dd415"><td class="memItemLeft" align="right" valign="top"><a id="gaf37c080c298e92468a3f6972f57dd415"></a>
typedef struct <a class="el" href="struct__Ecore__Exe__Event__Add.html">_Ecore_Exe_Event_Add</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gaf37c080c298e92468a3f6972f57dd415">Ecore_Exe_Event_Add</a></td></tr>
<tr class="memdesc:gaf37c080c298e92468a3f6972f57dd415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawned Exe add event. <br /></td></tr>
<tr class="separator:gaf37c080c298e92468a3f6972f57dd415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce66424ac56c676b996ea162482a8e9"><td class="memItemLeft" align="right" valign="top"><a id="ga5ce66424ac56c676b996ea162482a8e9"></a>
typedef struct <a class="el" href="struct__Ecore__Exe__Event__Del.html">_Ecore_Exe_Event_Del</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga5ce66424ac56c676b996ea162482a8e9">Ecore_Exe_Event_Del</a></td></tr>
<tr class="memdesc:ga5ce66424ac56c676b996ea162482a8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawned Exe exit event. <br /></td></tr>
<tr class="separator:ga5ce66424ac56c676b996ea162482a8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga938d59de6a9385e7d98c4b45f809d23f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga938d59de6a9385e7d98c4b45f809d23f">_Ecore_Exe_Win32_Priority</a> { <br />
&#160;&#160;<a class="el" href="group__Ecore__Exe__Group.html#gga938d59de6a9385e7d98c4b45f809d23fa09f6aedb549a47677c3810995128304b">ECORE_EXE_WIN32_PRIORITY_IDLE</a>
, <br />
&#160;&#160;<a class="el" href="group__Ecore__Exe__Group.html#gga938d59de6a9385e7d98c4b45f809d23fa9402a8afb6fbccde2f4b8ea7c8330de6">ECORE_EXE_WIN32_PRIORITY_BELOW_NORMAL</a>
, <br />
&#160;&#160;<a class="el" href="group__Ecore__Exe__Group.html#gga938d59de6a9385e7d98c4b45f809d23fa9683498607dc0bec65c4252b7e91708e">ECORE_EXE_WIN32_PRIORITY_NORMAL</a>
, <br />
&#160;&#160;<a class="el" href="group__Ecore__Exe__Group.html#gga938d59de6a9385e7d98c4b45f809d23fa0be06f30e0e5ff0a616ec31859dc83b5">ECORE_EXE_WIN32_PRIORITY_ABOVE_NORMAL</a>
, <br />
&#160;&#160;<a class="el" href="group__Ecore__Exe__Group.html#gga938d59de6a9385e7d98c4b45f809d23fa430693ca4ff578d64c39aa72edc1a7a6">ECORE_EXE_WIN32_PRIORITY_HIGH</a>
, <br />
&#160;&#160;<a class="el" href="group__Ecore__Exe__Group.html#gga938d59de6a9385e7d98c4b45f809d23fa0b4330d21ae5dc02b8de2e92133e604b">ECORE_EXE_WIN32_PRIORITY_REALTIME</a>
<br />
 }</td></tr>
<tr class="memdesc:ga938d59de6a9385e7d98c4b45f809d23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the priority of the process.  <a href="group__Ecore__Exe__Group.html#ga938d59de6a9385e7d98c4b45f809d23f">More...</a><br /></td></tr>
<tr class="separator:ga938d59de6a9385e7d98c4b45f809d23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0814e120655d40962dbf78c919d48ea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga0814e120655d40962dbf78c919d48ea9">ecore_exe_run_priority_set</a> (int pri)</td></tr>
<tr class="memdesc:ga0814e120655d40962dbf78c919d48ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the priority at which to launch processes.  <a href="group__Ecore__Exe__Group.html#ga0814e120655d40962dbf78c919d48ea9">More...</a><br /></td></tr>
<tr class="separator:ga0814e120655d40962dbf78c919d48ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8e54149852c0e65ab209e1f864437f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gae8e54149852c0e65ab209e1f864437f4">ecore_exe_run_priority_get</a> (void)</td></tr>
<tr class="memdesc:gae8e54149852c0e65ab209e1f864437f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the priority at which to launch processes.  <a href="group__Ecore__Exe__Group.html#gae8e54149852c0e65ab209e1f864437f4">More...</a><br /></td></tr>
<tr class="separator:gae8e54149852c0e65ab209e1f864437f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d56e17987c8e000119353093a34f0bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga5d56e17987c8e000119353093a34f0bc">ecore_exe_run</a> (const char *exe_cmd, const void *data)</td></tr>
<tr class="memdesc:ga5d56e17987c8e000119353093a34f0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a child process.  <a href="group__Ecore__Exe__Group.html#ga5d56e17987c8e000119353093a34f0bc">More...</a><br /></td></tr>
<tr class="separator:ga5d56e17987c8e000119353093a34f0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd208a964c62424424d4c4c92a651db1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gacd208a964c62424424d4c4c92a651db1">ecore_exe_pipe_run</a> (const char *exe_cmd, <a class="el" href="group__Ecore.html#ga26f57bfa7ecfa8eee5fc053e342880c5">Ecore_Exe_Flags</a> flags, const void *data)</td></tr>
<tr class="memdesc:gacd208a964c62424424d4c4c92a651db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a child process with its stdin/out available for communication.  <a href="group__Ecore__Exe__Group.html#gacd208a964c62424424d4c4c92a651db1">More...</a><br /></td></tr>
<tr class="separator:gacd208a964c62424424d4c4c92a651db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9759c16828017a493069d924edc588a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga9759c16828017a493069d924edc588a9">ecore_exe_callback_pre_free_set</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe, <a class="el" href="group__Ecore__Exe__Group.html#ga13ecbbae5c3cd4a8cb6b6267cdb984c9">Ecore_Exe_Cb</a> func)</td></tr>
<tr class="memdesc:ga9759c16828017a493069d924edc588a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a function to be called before really freeing the handle data.  <a href="group__Ecore__Exe__Group.html#ga9759c16828017a493069d924edc588a9">More...</a><br /></td></tr>
<tr class="separator:ga9759c16828017a493069d924edc588a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a7d73f64baf6b752154836ff4123b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gac5a7d73f64baf6b752154836ff4123b9">ecore_exe_send</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe, const void *data, int size)</td></tr>
<tr class="memdesc:gac5a7d73f64baf6b752154836ff4123b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data to the given child process which it receives on stdin.  <a href="group__Ecore__Exe__Group.html#gac5a7d73f64baf6b752154836ff4123b9">More...</a><br /></td></tr>
<tr class="separator:gac5a7d73f64baf6b752154836ff4123b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86dbd7abd0982a3067a29d6a2e752530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga86dbd7abd0982a3067a29d6a2e752530">ecore_exe_close_stdin</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga86dbd7abd0982a3067a29d6a2e752530"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stdin of the given child process will close when the write buffer is empty.  <a href="group__Ecore__Exe__Group.html#ga86dbd7abd0982a3067a29d6a2e752530">More...</a><br /></td></tr>
<tr class="separator:ga86dbd7abd0982a3067a29d6a2e752530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe2266fa29b2c4e59a52e03cc63d5318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gafe2266fa29b2c4e59a52e03cc63d5318">ecore_exe_auto_limits_set</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe, int start_bytes, int end_bytes, int start_lines, int end_lines)</td></tr>
<tr class="memdesc:gafe2266fa29b2c4e59a52e03cc63d5318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the auto pipe limits for the given process handle.  <a href="group__Ecore__Exe__Group.html#gafe2266fa29b2c4e59a52e03cc63d5318">More...</a><br /></td></tr>
<tr class="separator:gafe2266fa29b2c4e59a52e03cc63d5318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad50f57fe32eb478915ec84585c5ee65d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__Ecore__Exe__Event__Data.html">Ecore_Exe_Event_Data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gad50f57fe32eb478915ec84585c5ee65d">ecore_exe_event_data_get</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe, <a class="el" href="group__Ecore.html#ga26f57bfa7ecfa8eee5fc053e342880c5">Ecore_Exe_Flags</a> flags)</td></tr>
<tr class="memdesc:gad50f57fe32eb478915ec84585c5ee65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the auto pipe data for the given process handle.  <a href="group__Ecore__Exe__Group.html#gad50f57fe32eb478915ec84585c5ee65d">More...</a><br /></td></tr>
<tr class="separator:gad50f57fe32eb478915ec84585c5ee65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fd894d8e941928d0fa18de7ac922fae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga5fd894d8e941928d0fa18de7ac922fae">ecore_exe_event_data_free</a> (<a class="el" href="struct__Ecore__Exe__Event__Data.html">Ecore_Exe_Event_Data</a> *data)</td></tr>
<tr class="memdesc:ga5fd894d8e941928d0fa18de7ac922fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given event data.  <a href="group__Ecore__Exe__Group.html#ga5fd894d8e941928d0fa18de7ac922fae">More...</a><br /></td></tr>
<tr class="separator:ga5fd894d8e941928d0fa18de7ac922fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0948b947e85cf65c7a4e048705dcab8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gab0948b947e85cf65c7a4e048705dcab8">ecore_exe_free</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:gab0948b947e85cf65c7a4e048705dcab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given process handle.  <a href="group__Ecore__Exe__Group.html#gab0948b947e85cf65c7a4e048705dcab8">More...</a><br /></td></tr>
<tr class="separator:gab0948b947e85cf65c7a4e048705dcab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31fa4d88303d0dc45b3dfdb55fb53883"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga31fa4d88303d0dc45b3dfdb55fb53883">ecore_exe_pid_get</a> (const <a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga31fa4d88303d0dc45b3dfdb55fb53883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the process ID of the given spawned process.  <a href="group__Ecore__Exe__Group.html#ga31fa4d88303d0dc45b3dfdb55fb53883">More...</a><br /></td></tr>
<tr class="separator:ga31fa4d88303d0dc45b3dfdb55fb53883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b00cbbfb0686c51638f615055f35ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga6b00cbbfb0686c51638f615055f35ddd">ecore_exe_tag_set</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe, const char *tag)</td></tr>
<tr class="memdesc:ga6b00cbbfb0686c51638f615055f35ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the string tag for the given process handle.  <a href="group__Ecore__Exe__Group.html#ga6b00cbbfb0686c51638f615055f35ddd">More...</a><br /></td></tr>
<tr class="separator:ga6b00cbbfb0686c51638f615055f35ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546181ce36424f7bc8494ca6a5d003c3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga546181ce36424f7bc8494ca6a5d003c3">ecore_exe_tag_get</a> (const <a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga546181ce36424f7bc8494ca6a5d003c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the tag attached to the given process handle.  <a href="group__Ecore__Exe__Group.html#ga546181ce36424f7bc8494ca6a5d003c3">More...</a><br /></td></tr>
<tr class="separator:ga546181ce36424f7bc8494ca6a5d003c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac271d6626b589b109652ad1436aa8abc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gac271d6626b589b109652ad1436aa8abc">ecore_exe_cmd_get</a> (const <a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:gac271d6626b589b109652ad1436aa8abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the command of the given spawned process.  <a href="group__Ecore__Exe__Group.html#gac271d6626b589b109652ad1436aa8abc">More...</a><br /></td></tr>
<tr class="separator:gac271d6626b589b109652ad1436aa8abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga042dd98c0d59db095966f44560b617c8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga042dd98c0d59db095966f44560b617c8">ecore_exe_data_get</a> (const <a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga042dd98c0d59db095966f44560b617c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the data attached to the given process handle.  <a href="group__Ecore__Exe__Group.html#ga042dd98c0d59db095966f44560b617c8">More...</a><br /></td></tr>
<tr class="separator:ga042dd98c0d59db095966f44560b617c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c50db4f2818b9e99368493a6b37ffc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga17c50db4f2818b9e99368493a6b37ffc">ecore_exe_data_set</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe, void *data)</td></tr>
<tr class="memdesc:ga17c50db4f2818b9e99368493a6b37ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data attached to the given process handle.  <a href="group__Ecore__Exe__Group.html#ga17c50db4f2818b9e99368493a6b37ffc">More...</a><br /></td></tr>
<tr class="separator:ga17c50db4f2818b9e99368493a6b37ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd9d9fbc56e7f11d0426e836b67f5f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore.html#ga26f57bfa7ecfa8eee5fc053e342880c5">Ecore_Exe_Flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga9dd9d9fbc56e7f11d0426e836b67f5f3">ecore_exe_flags_get</a> (const <a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga9dd9d9fbc56e7f11d0426e836b67f5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the flags attached to the given process handle.  <a href="group__Ecore__Exe__Group.html#ga9dd9d9fbc56e7f11d0426e836b67f5f3">More...</a><br /></td></tr>
<tr class="separator:ga9dd9d9fbc56e7f11d0426e836b67f5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d82c76a7c0d504651de45416b9be22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga06d82c76a7c0d504651de45416b9be22">ecore_exe_pause</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga06d82c76a7c0d504651de45416b9be22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses the given process by sending it a <code>SIGSTOP</code> signal.  <a href="group__Ecore__Exe__Group.html#ga06d82c76a7c0d504651de45416b9be22">More...</a><br /></td></tr>
<tr class="separator:ga06d82c76a7c0d504651de45416b9be22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec2599ea787d30df5a9c0fdba57f2e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga9ec2599ea787d30df5a9c0fdba57f2e7">ecore_exe_continue</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga9ec2599ea787d30df5a9c0fdba57f2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continues the given paused process by sending it a <code>SIGCONT</code> signal.  <a href="group__Ecore__Exe__Group.html#ga9ec2599ea787d30df5a9c0fdba57f2e7">More...</a><br /></td></tr>
<tr class="separator:ga9ec2599ea787d30df5a9c0fdba57f2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a340e85e138d0bcbba8167e7461cc0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga4a340e85e138d0bcbba8167e7461cc0d">ecore_exe_interrupt</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga4a340e85e138d0bcbba8167e7461cc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given spawned process a interrupt (<code>SIGINT</code>) signal.  <a href="group__Ecore__Exe__Group.html#ga4a340e85e138d0bcbba8167e7461cc0d">More...</a><br /></td></tr>
<tr class="separator:ga4a340e85e138d0bcbba8167e7461cc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab24e92caaccfd7363d16408e7ccc626e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gab24e92caaccfd7363d16408e7ccc626e">ecore_exe_quit</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:gab24e92caaccfd7363d16408e7ccc626e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given spawned process a quit (<code>SIGQUIT</code>) signal.  <a href="group__Ecore__Exe__Group.html#gab24e92caaccfd7363d16408e7ccc626e">More...</a><br /></td></tr>
<tr class="separator:gab24e92caaccfd7363d16408e7ccc626e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c9a539eed895a001256bdee44fe0c73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga0c9a539eed895a001256bdee44fe0c73">ecore_exe_terminate</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga0c9a539eed895a001256bdee44fe0c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given spawned process a terminate (<code>SIGTERM</code>) signal.  <a href="group__Ecore__Exe__Group.html#ga0c9a539eed895a001256bdee44fe0c73">More...</a><br /></td></tr>
<tr class="separator:ga0c9a539eed895a001256bdee44fe0c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33305587a363c6f43bff032f94df6e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga33305587a363c6f43bff032f94df6e16">ecore_exe_kill</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga33305587a363c6f43bff032f94df6e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kills the given spawned process by sending it a <code>SIGKILL</code> signal.  <a href="group__Ecore__Exe__Group.html#ga33305587a363c6f43bff032f94df6e16">More...</a><br /></td></tr>
<tr class="separator:ga33305587a363c6f43bff032f94df6e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf986356eee28b04d156b24cbdf277a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gabf986356eee28b04d156b24cbdf277a0">ecore_exe_signal</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe, int num)</td></tr>
<tr class="memdesc:gabf986356eee28b04d156b24cbdf277a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a <code>SIGUSR</code> signal to the given spawned process.  <a href="group__Ecore__Exe__Group.html#gabf986356eee28b04d156b24cbdf277a0">More...</a><br /></td></tr>
<tr class="separator:gabf986356eee28b04d156b24cbdf277a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d11d21a5a761dd20d729c4394958ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga44d11d21a5a761dd20d729c4394958ae">ecore_exe_hup</a> (<a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *exe)</td></tr>
<tr class="memdesc:ga44d11d21a5a761dd20d729c4394958ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a <code>SIGHUP</code> signal to the given spawned process.  <a href="group__Ecore__Exe__Group.html#ga44d11d21a5a761dd20d729c4394958ae">More...</a><br /></td></tr>
<tr class="separator:ga44d11d21a5a761dd20d729c4394958ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga288ddcacabf7eb953d8199a027113ba0"><td class="memItemLeft" align="right" valign="top"><a id="ga288ddcacabf7eb953d8199a027113ba0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga288ddcacabf7eb953d8199a027113ba0">ECORE_EXE_EVENT_ADD</a></td></tr>
<tr class="memdesc:ga288ddcacabf7eb953d8199a027113ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A child process has been added. <br /></td></tr>
<tr class="separator:ga288ddcacabf7eb953d8199a027113ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad156c5e5f46e3d3ca45cb1c4e118eae1"><td class="memItemLeft" align="right" valign="top"><a id="gad156c5e5f46e3d3ca45cb1c4e118eae1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gad156c5e5f46e3d3ca45cb1c4e118eae1">ECORE_EXE_EVENT_DEL</a></td></tr>
<tr class="memdesc:gad156c5e5f46e3d3ca45cb1c4e118eae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A child process has been deleted (it exited, naming consistent with the rest of ecore). <br /></td></tr>
<tr class="separator:gad156c5e5f46e3d3ca45cb1c4e118eae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a5071bbc714abfbcede55c39c6ecf8a"><td class="memItemLeft" align="right" valign="top"><a id="ga3a5071bbc714abfbcede55c39c6ecf8a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#ga3a5071bbc714abfbcede55c39c6ecf8a">ECORE_EXE_EVENT_DATA</a></td></tr>
<tr class="memdesc:ga3a5071bbc714abfbcede55c39c6ecf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data from a child process. <br /></td></tr>
<tr class="separator:ga3a5071bbc714abfbcede55c39c6ecf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab102bc8eb4e2b3c7418da7d910c90a9c"><td class="memItemLeft" align="right" valign="top"><a id="gab102bc8eb4e2b3c7418da7d910c90a9c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Exe__Group.html#gab102bc8eb4e2b3c7418da7d910c90a9c">ECORE_EXE_EVENT_ERROR</a></td></tr>
<tr class="memdesc:gab102bc8eb4e2b3c7418da7d910c90a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors from a child process. <br /></td></tr>
<tr class="separator:gab102bc8eb4e2b3c7418da7d910c90a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module is responsible for managing portable processes using Ecore. </p>
<p>With this module you're able to spawn processes and you also can pause, quit your spawned processes. An interaction between your process and those spawned is possible using pipes or signals.</p>
<p>Example </p><ul>
<li><a class="el" href="Ecore_exe_simple_example_c.html">Ecore_exe</a> </li>
</ul>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga938d59de6a9385e7d98c4b45f809d23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga938d59de6a9385e7d98c4b45f809d23f">&#9670;&nbsp;</a></span>_Ecore_Exe_Win32_Priority</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Ecore__Exe__Group.html#ga938d59de6a9385e7d98c4b45f809d23f">_Ecore_Exe_Win32_Priority</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the priority of the process. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga938d59de6a9385e7d98c4b45f809d23fa09f6aedb549a47677c3810995128304b"></a>ECORE_EXE_WIN32_PRIORITY_IDLE&#160;</td><td class="fielddoc"><p>Idle priority, for monitoring the system. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga938d59de6a9385e7d98c4b45f809d23fa9402a8afb6fbccde2f4b8ea7c8330de6"></a>ECORE_EXE_WIN32_PRIORITY_BELOW_NORMAL&#160;</td><td class="fielddoc"><p>Below default priority. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga938d59de6a9385e7d98c4b45f809d23fa9683498607dc0bec65c4252b7e91708e"></a>ECORE_EXE_WIN32_PRIORITY_NORMAL&#160;</td><td class="fielddoc"><p>Default priority. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga938d59de6a9385e7d98c4b45f809d23fa0be06f30e0e5ff0a616ec31859dc83b5"></a>ECORE_EXE_WIN32_PRIORITY_ABOVE_NORMAL&#160;</td><td class="fielddoc"><p>Above default priority. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga938d59de6a9385e7d98c4b45f809d23fa430693ca4ff578d64c39aa72edc1a7a6"></a>ECORE_EXE_WIN32_PRIORITY_HIGH&#160;</td><td class="fielddoc"><p>High priority, use with care as other threads in the system will not get processor time. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga938d59de6a9385e7d98c4b45f809d23fa0b4330d21ae5dc02b8de2e92133e604b"></a>ECORE_EXE_WIN32_PRIORITY_REALTIME&#160;</td><td class="fielddoc"><p>Realtime priority, should be almost never used as it can interrupt system threads that manage mouse input, keyboard input, and background disk flushing. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0814e120655d40962dbf78c919d48ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0814e120655d40962dbf78c919d48ea9">&#9670;&nbsp;</a></span>ecore_exe_run_priority_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_run_priority_set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the priority at which to launch processes. </p>
<p>This sets the priority of processes run by <a class="el" href="group__Ecore__Exe__Group.html#ga5d56e17987c8e000119353093a34f0bc" title="Spawns a child process.">ecore_exe_run()</a> and <a class="el" href="group__Ecore__Exe__Group.html#gacd208a964c62424424d4c4c92a651db1" title="Spawns a child process with its stdin/out available for communication.">ecore_exe_pipe_run()</a>. </p><ul>
<li>On Windows, the child process is created by default with the <a class="el" href="group__Ecore__Exe__Group.html#gga938d59de6a9385e7d98c4b45f809d23fa9683498607dc0bec65c4252b7e91708e">ECORE_EXE_WIN32_PRIORITY_NORMAL</a> priority, unless the calling process is in <a class="el" href="group__Ecore__Exe__Group.html#gga938d59de6a9385e7d98c4b45f809d23fa09f6aedb549a47677c3810995128304b">ECORE_EXE_WIN32_PRIORITY_IDLE</a> or <a class="el" href="group__Ecore__Exe__Group.html#gga938d59de6a9385e7d98c4b45f809d23fa9402a8afb6fbccde2f4b8ea7c8330de6">ECORE_EXE_WIN32_PRIORITY_BELOW_NORMAL</a> priority. In that case, the child process inherits this priority. </li>
<li>On other platforms, if set to <a class="el" href="group__Ecore__Exe__Group.html#ga2e582481831ba6241f6304dee1a158ec">ECORE_EXE_PRIORITY_INHERIT</a> child processes inherits the priority of their parent. This is the default.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pri</td><td>Value an Ecore_Exe_Win32_Priority value on Windows, <code>-20</code> to <code>19</code> or <a class="el" href="group__Ecore__Exe__Group.html#ga2e582481831ba6241f6304dee1a158ec">ECORE_EXE_PRIORITY_INHERIT</a> on other OS. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga6900a2b986f5536b73210e2560675cb0">EINA_MAIN_LOOP_CHECK_RETURN</a>.</p>

</div>
</div>
<a id="gae8e54149852c0e65ab209e1f864437f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8e54149852c0e65ab209e1f864437f4">&#9670;&nbsp;</a></span>ecore_exe_run_priority_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ecore_exe_run_priority_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the priority at which to launch processes. </p>
<p>This gets the priority of launched processes. See <a class="el" href="group__Ecore__Exe__Group.html#ga0814e120655d40962dbf78c919d48ea9" title="Sets the priority at which to launch processes.">ecore_exe_run_priority_set()</a> for details. This just returns the value set by this call.</p>
<dl class="section return"><dt>Returns</dt><dd>The value set by <a class="el" href="group__Ecore__Exe__Group.html#ga0814e120655d40962dbf78c919d48ea9" title="Sets the priority at which to launch processes.">ecore_exe_run_priority_set()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>.</p>

</div>
</div>
<a id="ga5d56e17987c8e000119353093a34f0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d56e17987c8e000119353093a34f0bc">&#9670;&nbsp;</a></span>ecore_exe_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a>* ecore_exe_run </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>exe_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns a child process. </p>
<p>This is now just a thin wrapper around <a class="el" href="group__Ecore__Exe__Group.html#gacd208a964c62424424d4c4c92a651db1" title="Spawns a child process with its stdin/out available for communication.">ecore_exe_pipe_run()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe_cmd</td><td>The command to run with <code>/bin/sh</code>. </td></tr>
    <tr><td class="paramname">data</td><td>Data to attach to the returned process handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A process handle to the spawned process. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When you use this function you will have no permissions to write or read on the pipe that connects you with the spawned process. If you need to do that use <a class="el" href="group__Ecore__Exe__Group.html#gacd208a964c62424424d4c4c92a651db1" title="Spawns a child process with its stdin/out available for communication.">ecore_exe_pipe_run()</a> with the appropriated flags. </dd></dl>

<p class="reference">References <a class="el" href="group__Ecore__Exe__Group.html#gacd208a964c62424424d4c4c92a651db1">ecore_exe_pipe_run()</a>, and <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__Eeze__Disk.html#ga45173ebbd5c0861b57a433bc67d9f4b2">eeze_disk_eject()</a>, and <a class="el" href="group__Eeze__Disk.html#gae3b4fe79fad40e303ad649e404e03245">eeze_disk_unmount()</a>.</p>

</div>
</div>
<a id="gacd208a964c62424424d4c4c92a651db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd208a964c62424424d4c4c92a651db1">&#9670;&nbsp;</a></span>ecore_exe_pipe_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a>* ecore_exe_pipe_run </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>exe_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore.html#ga26f57bfa7ecfa8eee5fc053e342880c5">Ecore_Exe_Flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns a child process with its stdin/out available for communication. </p>
<p>This function forks and runs the given command using <code>/bin/sh</code>.</p>
<p>Note that the process handle is only valid until a child process terminated event is received. After all handlers for the child process terminated event have been called, the handle will be freed by Ecore.</p>
<p>This function does the same thing as <a class="el" href="group__Ecore__Exe__Group.html#ga5d56e17987c8e000119353093a34f0bc" title="Spawns a child process.">ecore_exe_run()</a>, but also makes the standard in and/or out as well as stderr from the child process available for reading or writing. To write use <a class="el" href="group__Ecore__Exe__Group.html#gac5a7d73f64baf6b752154836ff4123b9" title="Sends data to the given child process which it receives on stdin.">ecore_exe_send()</a>. To read listen to ECORE_EXE_EVENT_DATA or ECORE_EXE_EVENT_ERROR events (set up handlers). Ecore may buffer read and error data until a newline character if asked for with the <code>flags</code>. All data will be included in the events (newlines will be replaced with NULLS if line buffered). ECORE_EXE_EVENT_DATA events will only happen if the process is run with ECORE_EXE_PIPE_READ enabled in the flags. The same with the error version. Writing will only be allowed with ECORE_EXE_PIPE_WRITE enabled in the flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe_cmd</td><td>The command to run with <code>/bin/sh</code>. </td></tr>
    <tr><td class="paramname">flags</td><td>The flag parameters for how to deal with inter-process I/O </td></tr>
    <tr><td class="paramname">data</td><td>Data to attach to the returned process handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A process handle to the spawned process. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ecore_exe_example_8c-example.html#a11">ecore_exe_example.c</a>.</dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__Ecore__Exe__Group.html#ga5d56e17987c8e000119353093a34f0bc">ecore_exe_run()</a>.</p>

</div>
</div>
<a id="ga9759c16828017a493069d924edc588a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9759c16828017a493069d924edc588a9">&#9670;&nbsp;</a></span>ecore_exe_callback_pre_free_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_callback_pre_free_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore__Exe__Group.html#ga13ecbbae5c3cd4a8cb6b6267cdb984c9">Ecore_Exe_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a function to be called before really freeing the handle data. </p>
<p>This might be useful for language bindings such as Python and Perl that need to deallocate wrappers associated with this handle.</p>
<p>This handle should never be modified by this call. It should be considered informative only. All getters are valid when the given function is called back.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>The child process to attach the pre_free function. </td></tr>
    <tr><td class="paramname">func</td><td>The function to call before <em>exe</em> is freed. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga6900a2b986f5536b73210e2560675cb0">EINA_MAIN_LOOP_CHECK_RETURN</a>.</p>

</div>
</div>
<a id="gac5a7d73f64baf6b752154836ff4123b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5a7d73f64baf6b752154836ff4123b9">&#9670;&nbsp;</a></span>ecore_exe_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> ecore_exe_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data to the given child process which it receives on stdin. </p>
<p>This function writes to a child processes standard in, with unlimited buffering. This call will never block. It may fail if the system runs out of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>The child process to send to </td></tr>
    <tr><td class="paramname">data</td><td>The data to send </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to send, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>EINA_TRUE</code> if successful, <code>EINA_FALSE</code> on failure. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ecore_exe_example_8c-example.html#a7">ecore_exe_example.c</a>.</dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>, <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>, <a class="el" href="group__Eina__Safety__Checks__Group.html#ga1dbe0d7e3c6b10f4bd49a2a132d73269">EINA_SAFETY_ON_TRUE_RETURN_VAL</a>, <a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>, and <a class="el" href="group__Eina__File__Group.html#ga24e93be9c5baa3aeab7021b64e290672">ERR</a>.</p>

</div>
</div>
<a id="ga86dbd7abd0982a3067a29d6a2e752530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86dbd7abd0982a3067a29d6a2e752530">&#9670;&nbsp;</a></span>ecore_exe_close_stdin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_close_stdin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stdin of the given child process will close when the write buffer is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>The child process </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga6900a2b986f5536b73210e2560675cb0">EINA_MAIN_LOOP_CHECK_RETURN</a>.</p>

</div>
</div>
<a id="gafe2266fa29b2c4e59a52e03cc63d5318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe2266fa29b2c4e59a52e03cc63d5318">&#9670;&nbsp;</a></span>ecore_exe_auto_limits_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_auto_limits_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the auto pipe limits for the given process handle. </p>
<p>On Windows this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>The given process handle. </td></tr>
    <tr><td class="paramname">start_bytes</td><td>Limit of bytes at start of output to buffer. </td></tr>
    <tr><td class="paramname">end_bytes</td><td>Limit of bytes at end of output to buffer. </td></tr>
    <tr><td class="paramname">start_lines</td><td>Limit of lines at start of output to buffer. </td></tr>
    <tr><td class="paramname">end_lines</td><td>Limit of lines at end of output to buffer. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga6900a2b986f5536b73210e2560675cb0">EINA_MAIN_LOOP_CHECK_RETURN</a>.</p>

</div>
</div>
<a id="gad50f57fe32eb478915ec84585c5ee65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad50f57fe32eb478915ec84585c5ee65d">&#9670;&nbsp;</a></span>ecore_exe_event_data_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Ecore__Exe__Event__Data.html">Ecore_Exe_Event_Data</a>* ecore_exe_event_data_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore.html#ga26f57bfa7ecfa8eee5fc053e342880c5">Ecore_Exe_Flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the auto pipe data for the given process handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>The given process handle. </td></tr>
    <tr><td class="paramname">flags</td><td>Is this a ECORE_EXE_PIPE_READ or ECORE_EXE_PIPE_ERROR? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event data. </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>.</p>

</div>
</div>
<a id="ga5fd894d8e941928d0fa18de7ac922fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fd894d8e941928d0fa18de7ac922fae">&#9670;&nbsp;</a></span>ecore_exe_event_data_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_event_data_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Ecore__Exe__Event__Data.html">Ecore_Exe_Event_Data</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the given event data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The given event data. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="struct__Ecore__Exe__Event__Data.html#a5af41c740afab1ba763ba2dc14807802">_Ecore_Exe_Event_Data::data</a>, and <a class="el" href="struct__Ecore__Exe__Event__Data.html#aabdb33b138a5f497330e9d905864a257">_Ecore_Exe_Event_Data::lines</a>.</p>

</div>
</div>
<a id="gab0948b947e85cf65c7a4e048705dcab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0948b947e85cf65c7a4e048705dcab8">&#9670;&nbsp;</a></span>ecore_exe_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ecore_exe_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the given process handle. </p>
<p>Note that the process that the handle represents is unaffected by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>The given process handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data attached to the handle when <a class="el" href="group__Ecore__Exe__Group.html#ga5d56e17987c8e000119353093a34f0bc">ecore_exe_run</a> was called. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ecore_exe_example_8c-example.html#a21">ecore_exe_example.c</a>.</dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>.</p>

</div>
</div>
<a id="ga31fa4d88303d0dc45b3dfdb55fb53883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31fa4d88303d0dc45b3dfdb55fb53883">&#9670;&nbsp;</a></span>ecore_exe_pid_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t ecore_exe_pid_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the process ID of the given spawned process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>Handle to the given spawned process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The process ID on success, <code>-1</code> otherwise. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ecore_exe_example_8c-example.html#a16">ecore_exe_example.c</a>.</dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>.</p>

</div>
</div>
<a id="ga6b00cbbfb0686c51638f615055f35ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b00cbbfb0686c51638f615055f35ddd">&#9670;&nbsp;</a></span>ecore_exe_tag_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_tag_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the string tag for the given process handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>The given process handle. </td></tr>
    <tr><td class="paramname">tag</td><td>The string tag to set on the process handle. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga6900a2b986f5536b73210e2560675cb0">EINA_MAIN_LOOP_CHECK_RETURN</a>.</p>

</div>
</div>
<a id="ga546181ce36424f7bc8494ca6a5d003c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga546181ce36424f7bc8494ca6a5d003c3">&#9670;&nbsp;</a></span>ecore_exe_tag_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ecore_exe_tag_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the tag attached to the given process handle. </p>
<p>There is no need to free it as it just returns the internal pointer value. This value is only valid as long as the <code>exe</code> is valid or until the tag is set to something else on this <code>exe</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>The given process handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string attached to <code>exe</code>. It is a handle to existing internal string and should not be modified, use <a class="el" href="group__Ecore__Exe__Group.html#ga6b00cbbfb0686c51638f615055f35ddd" title="Sets the string tag for the given process handle.">ecore_exe_tag_set()</a> to change it. It might be <code>NULL</code>. </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>.</p>

</div>
</div>
<a id="gac271d6626b589b109652ad1436aa8abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac271d6626b589b109652ad1436aa8abc">&#9670;&nbsp;</a></span>ecore_exe_cmd_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ecore_exe_cmd_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the command of the given spawned process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>Handle to the given spawned process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The command on success, <code>NULL</code> otherwise. This string is the pointer to the internal value and must not be modified in any way. </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>.</p>

</div>
</div>
<a id="ga042dd98c0d59db095966f44560b617c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga042dd98c0d59db095966f44560b617c8">&#9670;&nbsp;</a></span>ecore_exe_data_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ecore_exe_data_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the data attached to the given process handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>The given process handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data pointer attached to <code>exe</code> Given to <a class="el" href="group__Ecore__Exe__Group.html#ga5d56e17987c8e000119353093a34f0bc" title="Spawns a child process.">ecore_exe_run()</a> or <a class="el" href="group__Ecore__Exe__Group.html#gacd208a964c62424424d4c4c92a651db1" title="Spawns a child process with its stdin/out available for communication.">ecore_exe_pipe_run()</a> </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>.</p>

</div>
</div>
<a id="ga17c50db4f2818b9e99368493a6b37ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17c50db4f2818b9e99368493a6b37ffc">&#9670;&nbsp;</a></span>ecore_exe_data_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ecore_exe_data_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the data attached to the given process handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>The given process handle. </td></tr>
    <tr><td class="paramname">data</td><td>The pointer to attach. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data pointer previously attached to <code>exe</code> with <a class="el" href="group__Ecore__Exe__Group.html#ga5d56e17987c8e000119353093a34f0bc" title="Spawns a child process.">ecore_exe_run()</a>, <a class="el" href="group__Ecore__Exe__Group.html#gacd208a964c62424424d4c4c92a651db1" title="Spawns a child process with its stdin/out available for communication.">ecore_exe_pipe_run()</a>, or <a class="el" href="group__Ecore__Exe__Group.html#ga17c50db4f2818b9e99368493a6b37ffc" title="Sets the data attached to the given process handle.">ecore_exe_data_set()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1 </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>.</p>

</div>
</div>
<a id="ga9dd9d9fbc56e7f11d0426e836b67f5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dd9d9fbc56e7f11d0426e836b67f5f3">&#9670;&nbsp;</a></span>ecore_exe_flags_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore.html#ga26f57bfa7ecfa8eee5fc053e342880c5">Ecore_Exe_Flags</a> ecore_exe_flags_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the flags attached to the given process handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>The given process handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The flags attached to <code>exe</code>. </dd></dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga2974eb3f18404edcc375910cc7e4859c">EINA_MAIN_LOOP_CHECK_RETURN_VAL</a>.</p>

</div>
</div>
<a id="ga06d82c76a7c0d504651de45416b9be22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06d82c76a7c0d504651de45416b9be22">&#9670;&nbsp;</a></span>ecore_exe_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_pause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pauses the given process by sending it a <code>SIGSTOP</code> signal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>Process handle to the given process. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>.</p>

</div>
</div>
<a id="ga9ec2599ea787d30df5a9c0fdba57f2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ec2599ea787d30df5a9c0fdba57f2e7">&#9670;&nbsp;</a></span>ecore_exe_continue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_continue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continues the given paused process by sending it a <code>SIGCONT</code> signal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>Process handle to the given process. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>.</p>

</div>
</div>
<a id="ga4a340e85e138d0bcbba8167e7461cc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a340e85e138d0bcbba8167e7461cc0d">&#9670;&nbsp;</a></span>ecore_exe_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the given spawned process a interrupt (<code>SIGINT</code>) signal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>Process handle to the given process. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga6900a2b986f5536b73210e2560675cb0">EINA_MAIN_LOOP_CHECK_RETURN</a>.</p>

</div>
</div>
<a id="gab24e92caaccfd7363d16408e7ccc626e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab24e92caaccfd7363d16408e7ccc626e">&#9670;&nbsp;</a></span>ecore_exe_quit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_quit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the given spawned process a quit (<code>SIGQUIT</code>) signal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>Process handle to the given process. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga6900a2b986f5536b73210e2560675cb0">EINA_MAIN_LOOP_CHECK_RETURN</a>.</p>

</div>
</div>
<a id="ga0c9a539eed895a001256bdee44fe0c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c9a539eed895a001256bdee44fe0c73">&#9670;&nbsp;</a></span>ecore_exe_terminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_terminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the given spawned process a terminate (<code>SIGTERM</code>) signal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>Process handle to the given process. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga6900a2b986f5536b73210e2560675cb0">EINA_MAIN_LOOP_CHECK_RETURN</a>.</p>

</div>
</div>
<a id="ga33305587a363c6f43bff032f94df6e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33305587a363c6f43bff032f94df6e16">&#9670;&nbsp;</a></span>ecore_exe_kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_kill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kills the given spawned process by sending it a <code>SIGKILL</code> signal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>Process handle to the given process. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga6900a2b986f5536b73210e2560675cb0">EINA_MAIN_LOOP_CHECK_RETURN</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__Eeze__Disk.html#ga3d690cd04047439551a8f2c3855b8cd7">eeze_disk_cancel()</a>, and <a class="el" href="group__Eeze__Disk.html#gac3061cc01944ac6745ef009ff6c97297">eeze_disk_free()</a>.</p>

</div>
</div>
<a id="gabf986356eee28b04d156b24cbdf277a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf986356eee28b04d156b24cbdf277a0">&#9670;&nbsp;</a></span>ecore_exe_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a <code>SIGUSR</code> signal to the given spawned process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>Process handle to the given process. </td></tr>
    <tr><td class="paramname">num</td><td>The number user signal to send. Must be either <code>1</code> or <code>2</code>, or the signal will be ignored. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga6900a2b986f5536b73210e2560675cb0">EINA_MAIN_LOOP_CHECK_RETURN</a>.</p>

</div>
</div>
<a id="ga44d11d21a5a761dd20d729c4394958ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d11d21a5a761dd20d729c4394958ae">&#9670;&nbsp;</a></span>ecore_exe_hup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ecore_exe_hup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEcore__Exe.html">Ecore_Exe</a> *&#160;</td>
          <td class="paramname"><em>exe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a <code>SIGHUP</code> signal to the given spawned process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exe</td><td>Process handle to the given process. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__Eina__Lock__Group.html#ga6900a2b986f5536b73210e2560675cb0">EINA_MAIN_LOOP_CHECK_RETURN</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="footer">
  <p>
    <span class="version">EFL 1.26.99</span>
    <span class="copyright">Copyright &copy;2000-2022 <a href="http://www.enlightenment.org">enlightenment.org</a></span>
    <span class="generated">Generated @ Sat Oct 29 2022 18:10:49</span>
  </p>
</div>
</body>
</html>
