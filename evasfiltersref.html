<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Evas filters reference</title>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-110876574-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-110876574-1');
  </script>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link rel="icon" href="favicon.png" type="image/x-icon">
  <link rel="shortcut icon" href="favicon.png" type="image/x-icon">
  <link rel="icon" href="favicon.png" type="image/ico">
  <link rel="shortcut icon" href="favicon.png" type="image/ico">
  <link rel="stylesheet" type="text/css" href="e.css">
</head>
<body>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Evas filters reference </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Apply inverse color TODO: write down more information.</p>
<p>Remove color information from buffer's contents and leave only grayscale TODO: write down more information.</p>
<dl class="section warning"><dt>Warning</dt><dd>A new online documentation is available on the Wiki under <a href="https://www.enlightenment.org/docs/efl/advanced/eflgfxfilters">EFL Graphics Filters</a>. The documentation below is mostly still valid but incomplete. This page may be removed in the future.</dd></dl>
<p>The Evas filters are a combination of filters used to apply specific effects to an <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas Object</a>. For the moment, these effects are specific to the Text and <a class="el" href="group__Evas__Object__Image.html">Image Objects</a>.</p>
<p>The filters can be applied to an object using simple Lua scripts. A script will contain a series of buffer declarations and filter commands to apply to these buffers. The Lua programming language reference can be found <a href="http://www.lua.org/manual/5.1/manual.html">here</a>.</p>
<p>Basically, when applying an effect to a Text Object, an alpha-only <code>input</code> buffer is created, where the text is rendered, and an RGBA <code>output</code> buffer is created, where the text with effects shall be finally rendered.</p>
<p>The script language being Lua, it respects the usual Lua syntax and concepts. As these are simple filters, the scripts should be kept as small and simple as possible.</p>
<p>Note: Lua has been used since 1.10. The previous filters syntax is not guaranteed to be compatible with 1.10 and newer versions.</p>
<p>Here are the available commands: </p><ul>
<li>
<a class="el" href="evasfiltersref.html#sec_syntax">Syntax</a>  </li>
<li>
<a class="el" href="evasfiltersref.html#sec_buffers">Buffer management</a>  <ul>
<li>
<a class="el" href="evasfiltersref.html#sec_buffers_cspace">Colorspaces</a>  </li>
<li>
<a class="el" href="evasfiltersref.html#sec_buffers_auto">Automatic buffers</a>  </li>
<li>
<a class="el" href="evasfiltersref.html#sec_buffers_cmd"><code>buffer</code> command</a>  </li>
</ul>
</li>
<li>
<a class="el" href="evasfiltersref.html#sec_commands">Commands</a>  <ul>
<li>
<a class="el" href="evasfiltersref.html#sec_commands_blend"><code>blend</code> command</a> </li>
<li>
<a class="el" href="evasfiltersref.html#sec_commands_blur"><code>blur</code> command</a> </li>
<li>
<a class="el" href="evasfiltersref.html#sec_commands_grow"><code>grow</code> command</a> </li>
<li>
<a class="el" href="evasfiltersref.html#sec_commands_curve"><code>curve</code> command</a> </li>
<li>
<a class="el" href="evasfiltersref.html#sec_commands_fill"><code>fill</code> command</a> </li>
<li>
<a class="el" href="evasfiltersref.html#sec_commands_mask"><code>mask</code> command</a> </li>
<li>
<a class="el" href="evasfiltersref.html#sec_commands_bump"><code>bump</code> command</a> </li>
<li>
<a class="el" href="evasfiltersref.html#sec_commands_displace"><code>displace</code> command</a> </li>
<li>
<a class="el" href="evasfiltersref.html#sec_commands_transform"><code>transform</code> command</a> </li>
</ul>
</li>
</ul>
<p>All the examples in this page can (should) be directly used in evas_obj_text_filter_program_set.</p>
<p>Note that most of the text effects work better with larger font sizes (&gt; 50px), and so do the examples in this page (embedded devices in mind).</p>
<h1><a class="anchor" id="sec_syntax"></a>
Syntax</h1>
<p>Here is a simple example illustrating the syntax:</p>
<pre class="fragment">fat = buffer ('alpha')
grow ({ 8, dst = fat })
blur ({ 12, src = fat, color = 'darkblue' })
blur ({ 4, color = 'cyan' })
blend ()
</pre><p>This example will display a cyan and dark blue glow surrounding the main text (its color depends on the object's theme).</p>
<center> <div class="image">
<img src="filter_example_1.png" alt=""/>
</div>
 </center><p>The syntax is pretty simple and follows a small set of rules: </p><ul>
<li>
All dimensions are in pixels </li>
<li>
The commands will be executed in sequential order </li>
<li>
Most commands have default values </li>
<li>
A command argument can either be set by name, or sequentially omitting the name. So that:<br  />
 <pre class="fragment">function (arg1, arg2, arg3) </pre> </li>
<li>
is equivalent to:<br  />
 <pre class="fragment">function ({ arg1, arg2, arg2 }) </pre> </li>
<li>
or even (considering opt1, opt2 and opt3 are the first 3 arguments):<br  />
 <pre class="fragment">function ({ opt1 = arg1, opt2 = arg2, opt3 = arg3 }) </pre> </li>
<li>
and since this is Lua, we can also write it as:<br  />
 <pre class="fragment">function { arg1, opt3 = arg3, opt2 = arg2 } </pre> </li>
<li>
Boolean values are <code>true/<code>false</code> but</code> 1/0 and special string values are also accepted: 'yes'/'no', 'enabled'/'disabled' </li>
</ul>
<h3>Special keywords and their values</h3>
<p>Some options accept a certain set of values (like enums): </p><ul>
<li>
<code>color</code> <a class="anchor" id="evasfilters_color"></a> <ul>
<li>
Colors can be referred to by strings or integers: </li>
<li>
An integer can refer to any RGB or ARGB values: <code>0xRRGGBB</code> or <code>0xAARRGGBB</code>. If alpha is zero, the color will be opaque (alpha = <code>0xFF</code>), unless R=G=B=0 (invisible). These colors are <b>not</b> premultiplied.  </li>
<li>
Hexadecimal values: <code>'#RRGGBB'</code>, <code>'#RRGGBBAA'</code>, <code>'#RGB'</code>, <code>'#RGBA'</code> </li>
<li>
The following string values are also accepted: <code><ul>
<li>
'white' == '#FFFFFF' </li>
<li>
'black' == '#000000' </li>
<li>
'red' == '#FF0000' </li>
<li>
'green' == '#008000' </li>
<li>
'blue' == '#0000FF' </li>
<li>
'darkblue' == '#0000A0' </li>
<li>
'yellow' == '#FFFF00' </li>
<li>
'magenta' == '#FF00FF' </li>
<li>
'cyan' == '#00FFFF' </li>
<li>
'orange' == '#FFA500' </li>
<li>
'purple' == '#800080' </li>
<li>
'brown' == '#A52A2A' </li>
<li>
'maroon' == '#800000' </li>
<li>
'lime' == '#00FF00' </li>
<li>
'gray' == '#808080' </li>
<li>
'grey' == '#808080' </li>
<li>
'silver' == '#C0C0C0' </li>
<li>
'olive' == '#808000' </li>
<li>
'invisible', 'transparent' == '#0000' &ndash; (alpha is zero) </li>
</ul>
</code> </li>
</ul>
</li>
<li>
<code>fillmode</code> <a class="anchor" id="evasfilter_fillmode"></a> <code><ul>
<li>
'none' </li>
<li>
'stretch_x' </li>
<li>
'stretch_y' </li>
<li>
'repeat_x' </li>
<li>
'repeat_y' </li>
<li>
'repeat_x_stretch_y', 'stretch_y_repeat_x' </li>
<li>
'repeat_y_stretch_x', 'stretch_x_repeat_y' </li>
<li>
'repeat', 'repeat_xy' </li>
<li>
'stretch', 'stretch_xy' </li>
</ul>
</code> </li>
</ul>
<h1><a class="anchor" id="sec_buffers"></a>
Buffer management</h1>
<p>The Evas filters subsystem is based on the concept of using various buffers as image layers and drawing or applying filters to these buffers. Think of it as how image drawing tools like The Gimp can combine multiple layers and apply operations on them.</p>
<p>Most of the buffers are allocated automatically at runtime, depending on the various inputs and commands used (eg. 2-D blur will require a temporary intermediate buffer).</p>
<h2><a class="anchor" id="sec_buffers_cspace"></a>
Colorspaces and size</h2>
<p>The buffers' size will be automatically defined at runtime, based on the content of the input and the series of operations to apply (eg. blur adds some necessary margins).</p>
<p>The buffers can be either ALPHA (1 color channel only) or RGBA (full color). Some operations might require specifically an ALPHA buffer, some others RGBA.</p>
<p>Most buffers will have the same size, except those specified by an external source.</p>
<h2><a class="anchor" id="sec_buffers_auto"></a>
Automatic buffers</h2>
<p>The two most important buffers, input and output, are statically defined and always present when running a filter. input is an ALPHA buffer, containing the Text Object's rendered text, and output is the final target on which to render as RGBA.</p>
<p>Some operations, like 2-D blur might require temporary intermediate buffers, that will be allocated automatically. Those buffers are internal only and can't be used from the script.</p>
<p>Finally, if a buffer is created using another Evas Object as source (see <a class="el" href="evasfiltersref.html#sec_buffers_cmd">buffer</a> for more details), its pixel data will be filled by rendering the Evas Object into this buffer. This is how it will be possible to load external images, textures and even animations into a buffer.</p>
<dl class="section since"><dt>Since</dt><dd>1.9</dd></dl>
<h2><a class="anchor" id="sec_buffers_cmd"></a>
Buffer command</h2>
<p>Create a new buffer.</p>
<pre class="fragment">name1 = buffer()
name2 = buffer("alpha")
name3 = buffer("rgba")
name4 = buffer({ type = "rgba" })
name5 = buffer({ src = "partname" })
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Buffer type: <code>rgba</code> (default) or <code>alpha</code> </td></tr>
    <tr><td class="paramname">src</td><td>An optional source. If set, <em>type</em> will be <code>rgba</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new buffer. This value must not be saved to a variable.</dd></dl>
<p>This creates a new named buffer, specify its colorspace or source. Possible options: </p><ul>
<li><code>alpha:</code> Create an alpha-only buffer (1 channel, no color) </li>
<li><code>rgba:</code> Create an RGBA buffer (4 channels, full color) </li>
<li><code>{src = "partname"}</code>: Use another <code>Evas Object</code> as source for this buffer's pixels. The name can either be an Edje part name or the one specified in <code>evas_obj_text_filter_source_set</code>.</li>
</ul>
<p>If no option is given, an RGBA buffer will be created. All buffers have the same size, unless they are based on an external source.</p>
<dl class="section see"><dt>See also</dt><dd>evas_obj_text_filter_source_set</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.10</dd></dl>
<h1><a class="anchor" id="sec_commands"></a>
Filter commands</h1>
<p>This section will present the various filter instructions, their syntax and their effects.</p>
<h2><a class="anchor" id="sec_commands_blend"></a>
Blend</h2>
<p>Blend a buffer onto another. This is the simplest filter, as it just renders one buffer on another, potentially using a color, an offset and fill options.</p>
<pre class="fragment">blend ({ src = input, dst = output, ox = 0, oy = 0, color = 'white', fillmode = 'none' })
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source buffer to blend. </td></tr>
    <tr><td class="paramname">dst</td><td>Destination buffer for blending. </td></tr>
    <tr><td class="paramname">ox</td><td>X offset. Moves the buffer to the right (ox &gt; 0) or to the left (ox &lt; 0) by N pixels. </td></tr>
    <tr><td class="paramname">oy</td><td>Y offset. Moves the buffer to the bottom (oy &gt; 0) or to the top (oy &lt; 0) by N pixels. </td></tr>
    <tr><td class="paramname">color</td><td>A color to use for alpha to RGBA conversion. See <a class="el" href="evasfiltersref.html#evasfilters_color">colors</a>. <br  />
 If the input is an alpha buffer and the output is RGBA, this will draw the buffer in this color. If both buffers are RGBA, this will have no effect. </td></tr>
    <tr><td class="paramname">fillmode</td><td>Map the input onto the whole surface of the output by stretching or repeating it. See <a class="el" href="evasfiltersref.html#evasfilter_fillmode">fillmodes</a>. </td></tr>
    <tr><td class="paramname">alphaonly</td><td>If true, this means all RGBA-&gt;Alpha conversions discard the RGB components entirely, and only use the Alpha channel. False by default, which means RGB is used as Grey color level.</td></tr>
  </table>
  </dd>
</dl>
<p>If <em>src</em> is an alpha buffer and <em>dst</em> is an RGBA buffer, then the <em>color</em> option should be set.</p>
<pre class="fragment">blend ({ color = '#3399FF' })
</pre><center> <div class="image">
<img src="filter_blend.png" alt=""/>
</div>
 </center><dl class="section since"><dt>Since</dt><dd>1.9</dd></dl>
<h2><a class="anchor" id="sec_commands_blur"></a>
Blur</h2>
<p>Apply blur effect on a buffer (box or gaussian).</p>
<pre class="fragment">blur ({ rx = 3, ry = nil, type = 'default', ox = 0, oy = 0, color = 'white', src = input, dst = output })
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx</td><td>X radius. Specifies the radius of the blurring kernel (X direction). </td></tr>
    <tr><td class="paramname">ry</td><td>Y radius. Specifies the radius of the blurring kernel (Y direction). If -1 is used, then <em>ry</em> = <em>rx</em>. </td></tr>
    <tr><td class="paramname">type</td><td>Blur type to apply. One of <code>default</code>, <code>box</code> or <code>gaussian</code>. See below for details about <code>default</code>. </td></tr>
    <tr><td class="paramname">ox</td><td>X offset. Moves the buffer to the right (<em>ox</em> &gt; 0) or to the left (<em>ox</em> &lt; 0) by N pixels. </td></tr>
    <tr><td class="paramname">oy</td><td>Y offset. Moves the buffer to the bottom (<em>oy</em> &gt; 0) or to the top (<em>oy</em> &lt; 0) by N pixels. </td></tr>
    <tr><td class="paramname">color</td><td>A color to use for alpha to RGBA conversion. See <a class="el" href="evasfiltersref.html#evasfilters_color">colors</a>. <br  />
 If the input is an alpha buffer and the output is RGBA, this will draw the buffer in this color. </td></tr>
    <tr><td class="paramname">src</td><td>Source buffer to blur. </td></tr>
    <tr><td class="paramname">dst</td><td>Destination buffer for blending. </td></tr>
    <tr><td class="paramname">count</td><td>Number of times to repeat the blur. Only valid with <code>box</code> blur. Valid range is: 1 to 6.</td></tr>
  </table>
  </dd>
</dl>
<p>The blur type <code>default</code> is <b>recommended in all situations</b> as it will select the smoothest and fastest operation possible depending on the kernel size. Instead of running a real gaussian blur, 2 or 3 box blurs may be chained to produce a similar effect at a much higher speed. The value <em>count</em> can be set to a value from 1 to 6 if blur type <code>box</code> has been specified.</p>
<p>The speedups of <code>box</code> over <code>gaussian</code> are of orders of 4x to more than 20x faster.</p>
<p>If <em>src</em> is an alpha buffer and <em>dst</em> is an RGBA buffer, then the color option should be set.</p>
<p><em>ox</em> and <em>oy</em> can be used to move the blurry output by a few pixels, like a drop shadow. Example: </p><pre class="fragment">blur ({ 10, color = 'black', oy = 5, ox = 5 })
blend ({ color = '#3399FF' })
</pre><center> <div class="image">
<img src="filter_blur.png" alt=""/>
</div>
 </center><dl class="section since"><dt>Since</dt><dd>1.9</dd></dl>
<h2><a class="anchor" id="sec_commands_bump"></a>
Bump</h2>
<p>Apply a light effect (ambient light, specular reflection and shadows) based on a bump map.</p>
<p>This can be used to give a relief effect on the object.</p>
<pre class="fragment">bump ({ map, azimuth = 135.0, elevation = 45.0, depth = 8.0, specular = 0.0,
        color = 'white', compensate = false, src = input, dst = output,
        black = 'black', white = 'white', fillmode = 'repeat' })
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>An alpha buffer treated like a Z map for the light effect (bump map). Must be specified. </td></tr>
    <tr><td class="paramname">azimuth</td><td>The angle between the light vector and the X axis in the XY plane (Z = 0). 135.0 means 45 degrees from the top-left. Counter-clockwise notation. </td></tr>
    <tr><td class="paramname">elevation</td><td>The angle between the light vector and the Z axis. 45.0 means 45 degrees to the screen's plane. Ranges from 0 to 90 only. </td></tr>
    <tr><td class="paramname">depth</td><td>The depth of the object in an arbitrary unit. More depth means the shadows will be stronger. Default is 8.0. </td></tr>
    <tr><td class="paramname">specular</td><td>An arbitrary unit for the specular light effect. Default is 0.0, but a common value would be 40.0. </td></tr>
    <tr><td class="paramname">color</td><td>The main color of the object if src is an alpha buffer. This represents the light's normal color. See <a class="el" href="evasfiltersref.html#evasfilters_color">colors</a>. </td></tr>
    <tr><td class="paramname">compensate</td><td>If set to true, compensate for whitening or darkening on flat surfaces. Default is false but it is recommended if specular light is wanted. </td></tr>
    <tr><td class="paramname">src</td><td>Source buffer. This should be an alpha buffer. </td></tr>
    <tr><td class="paramname">dst</td><td>Destination buffer. This should be an RGBA buffer (although alpha is supported). Must be of the same size as <em>src</em>. </td></tr>
    <tr><td class="paramname">black</td><td>The shadows' color. Usually this will be black (<code>#000</code>). </td></tr>
    <tr><td class="paramname">white</td><td>The specular light's color. Usually this will be white (<code>#FFF</code>). </td></tr>
    <tr><td class="paramname">fillmode</td><td>This specifies how to handle <em>map</em> when its dimensions don't match those of <em>src</em> and <em>dst</em>. Default is to <code>repeat</code>. See <a class="el" href="evasfiltersref.html#evasfilter_fillmode">fillmodes</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>As of 2014/02/11, the ALPHA to RGBA support is of much better quality than ALPHA only, but <b>very</b> slow. RGBA sources are not supported yet.</dd></dl>
<p>Here is a full example of a very simple bevel effect: </p><pre class="fragment">a = buffer ('alpha')
blur ({ 5, dst = a })
bump ({ map = a, compensate = true, color = '#3399FF', specular = 10.0 })
</pre><center> <div class="image">
<img src="filter_bump.png" alt=""/>
</div>
 </center><dl class="section since"><dt>Since</dt><dd>1.9</dd></dl>
<h2><a class="anchor" id="sec_commands_curve"></a>
Curve</h2>
<p>Apply a color curve to a specific channel in a buffer.</p>
<pre class="fragment">curve ({ points, interpolation = 'linear', channel = 'rgb', src = input, dst = output })
</pre><p>Modify the colors of a buffer. This applies a color curve y = f(x) to every pixel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The color curve to apply. See below for the syntax. </td></tr>
    <tr><td class="paramname">interpolation</td><td>How to interpolate between points. One of <code>linear</code> (y = ax + b) or <code>none</code> (y = Yk). </td></tr>
    <tr><td class="paramname">channel</td><td>Target channel for the color modification. One of <code>R(ed)</code>, <code>G(reen)</code>, <code>B(lue)</code>, <code>A(lpha)</code>, <code>RGB</code> and <code>RGBA</code>. If <em>src</em> is an alpha buffer, this parameter will be ignored. </td></tr>
    <tr><td class="paramname">src</td><td>Source buffer. </td></tr>
    <tr><td class="paramname">dst</td><td>Destination buffer, must be of same dimensions and color space as <em>src</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>points</em> argument contains a list of (X,Y) points in the range 0..255, describing a function <code>f(x) = y</code> to apply to all pixel values.</p>
<p>The syntax of this <em>points</em> string is <code>'x1:y1 - x2:y2 - x3:y3 - ... - xn:yn'</code> (remember that all spaces are discarded). The points <code>xn</code> are in <em>increasing</em> order: <code>x1 &lt; x2 &lt; x3 &lt; ... &lt; xn</code>, and all values <code>xn</code> or <code>yn</code> are within the range 0..255.</p>
<p>The identity curve is then described as <code>'0:0-255:255'</code>, with linear interpolation: </p><pre class="fragment">curve ({ points = '0:0 - 255:255', interpolation = linear })
</pre><p> If ignored, y(x = 0) is 0 and y(x = 255) is 255.</p>
<p>The following example will generate a 4px thick stroke around text letters: </p><pre class="fragment">a = buffer ('alpha')
blur ({ 4, dst = a })
curve ({ points = '0:0 - 20:0 - 60:255 - 160:255 - 200:0 - 255:0', src = a, dst = a })
blend ({ src = a, color = 'black' })
</pre><center> <div class="image">
<img src="filter_curve.png" alt=""/>
</div>
 </center><p>The curve command can be used to alter the output of a blur operation.</p>
<dl class="section since"><dt>Since</dt><dd>1.9</dd></dl>
<h2><a class="anchor" id="sec_commands_displace"></a>
Displace</h2>
<p>Apply a displacement map on a buffer.</p>
<pre class="fragment">displace ({ map, intensity = 10, flags = 0, src = input, dst = output, fillmode = 'repeat' })
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>An RGBA buffer containing a displacement map. See below for more details. </td></tr>
    <tr><td class="paramname">intensity</td><td>Maximum distance for the displacement. This means 0 and 255 will represent a displacement of <code>intensity</code> pixels. </td></tr>
    <tr><td class="paramname">flags</td><td>One of <code>default</code>, <code>nearest</code>, <code>smooth</code>, <code>nearest_stretch</code> or <code>smooth_stretch</code>. This defines how pixels should be treated when going out of the <em>src</em> image bounds. <code>default</code> is equivalent to <code>smooth_stretch</code>. </td></tr>
    <tr><td class="paramname">src</td><td>Source buffer </td></tr>
    <tr><td class="paramname">dst</td><td>Destination buffer. Must be of same color format and size as <em>src</em>. </td></tr>
    <tr><td class="paramname">fillmode</td><td>Defines how to handle cases where the map has a different size from <em>src</em> and <em>dst</em>. It should be a combination of <code>stretch</code> or <code>repeat:</code> <code>none</code> is not supported. See <a class="el" href="evasfiltersref.html#evasfilter_fillmode">fillmodes</a>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Displacement map</h3>
<p>The <em>map</em> buffer is an RGBA image containing displacement and alpha values. Its size can be different from <code>src</code> or <code>dst</code>.</p>
<p>The <b>red</b> channel is used for X displacements while the <b>green</b> channel is used for Y displacements. All subpixel values are in the range 0..255. A value of 128 means 0 displacement, lower means displace to the top/left and higher than 128 displace to the bottom/right.</p>
<p>If <code>signed char</code> is used instead of <code>unsigned char</code> to represent these R and G values, then &lt; 0 means displace top/left while &gt; 0 means bottom/right.</p>
<p>The <code>alpha</code> channel is used as an alpha multiplier for blending.</p>
<p>Considering <code>I(x, y)</code> represents the pixel at position (x, y) in the image I, then here is how the displacement is applied to <em>dst:</em> </p><pre class="fragment">D = map (x, y)
dst (x, y) = D.alpha * src (x + (D.red - 128) * intensity / 128, y + (D.green - 128) * intensity / 128) / 255 + (255 - D.alpha) * dst (x, y) / 255
</pre><p> Of course, the real algorithm takes into account interpolation between pixels as well.</p>
<dl class="section since"><dt>Since</dt><dd>1.9</dd></dl>
<h2><a class="anchor" id="sec_commands_fill"></a>
Fill</h2>
<p>Fill a buffer with a specific color. Not blending, can be used to clear a buffer.</p>
<pre class="fragment">fill ({ dst = output, color = 'transparent', l = 0, r = 0, t = 0, b = 0 })
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Target buffer to fill with <em>color</em>. </td></tr>
    <tr><td class="paramname">color</td><td>The color used to fill the buffer. All pixels within the fill area will be reset to this value. See <a class="el" href="evasfiltersref.html#evasfilters_color">colors</a>. </td></tr>
    <tr><td class="paramname">l</td><td>Left padding: skip <em>l</em> pixels from the left border of the buffer </td></tr>
    <tr><td class="paramname">r</td><td>Right padding: skip <em>r</em> pixels from the right border of the buffer </td></tr>
    <tr><td class="paramname">t</td><td>Top padding: skip <em>t</em> pixels from the top border of the buffer </td></tr>
    <tr><td class="paramname">b</td><td>Bottom padding: skip <em>b</em> pixels from the bottom border of the buffer</td></tr>
  </table>
  </dd>
</dl>
<p>This function should generally not be used, except for: </p><ul>
<li>
<em>Testing</em> an effect over a specific background color </li>
<li>
Clearing out a buffer with either white or transparent color </li>
</ul>
<dl class="section since"><dt>Since</dt><dd>1.9</dd></dl>
<h2><a class="anchor" id="sec_commands_grow"></a>
Grow</h2>
<p>Grow or shrink a buffer's contents. This is not a zoom effect.</p>
<pre class="fragment">grow ({ radius, smooth = true, src = input, dst = output })
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>The radius of the grow kernel. If a negative value is specified, the contents will shrink rather than grow. </td></tr>
    <tr><td class="paramname">smooth</td><td>If <code>true</code>, use a smooth transitions between black and white (smooth blur and smoother curve). </td></tr>
    <tr><td class="paramname">src</td><td>Source buffer to blur. </td></tr>
    <tr><td class="paramname">dst</td><td>Destination buffer for blending. This must be of same size and colorspace as <em>src</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">fat = buffer ('alpha')
grow ({ 8, dst = fat })
blend ({ src = fat, color = 'black' })
blend ({ color = '#3399FF' })
</pre><p>This will first grow the letters in the buffer <code>input</code> by a few pixels, and then draw this buffer in black in the background.</p>
<center> <div class="image">
<img src="filter_grow.png" alt=""/>
</div>
 </center><dl class="section since"><dt>Since</dt><dd>1.9</dd></dl>
<h2><a class="anchor" id="sec_commands_mask"></a>
Mask</h2>
<p>Blend two input buffers into a third (target).</p>
<pre class="fragment">mask ({ mask, src = input, dst = output, color = 'white', fillmode = 'repeat' })
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>A mask or texture to blend with the input <em>src</em> into the target <em>dst</em>. </td></tr>
    <tr><td class="paramname">src</td><td>Source buffer. This can also be thought of a mask if <em>src</em> is alpha and <em>mask</em> is RGBA. </td></tr>
    <tr><td class="paramname">dst</td><td>Destination buffer for blending. This must be of same size and colorspace as <em>src</em>. </td></tr>
    <tr><td class="paramname">color</td><td>A color to use for alpha to RGBA conversion for the blend operations. White means no change. See <a class="el" href="evasfiltersref.html#evasfilters_color">colors</a>. This will have no effect on RGBA sources. </td></tr>
    <tr><td class="paramname">fillmode</td><td>Defines whether to stretch or repeat the <em>mask</em> if its size that of <code>src</code>. Should be set when masking with external textures. Default is repeat. See <a class="el" href="evasfiltersref.html#evasfilter_fillmode">fillmodes</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that <em>src</em> and <em>mask</em> are interchangeable, if they have the same dimensions.</p>
<p>Example: </p><pre class="fragment">a = buffer ('alpha')
blur ({ 6, dst = a })
curve ({ points = '0:255 - 128:255 - 255:0', src = a, dst = a })
blend ({ color = 'yellow' })
mask ({ mask = a, color = 'black' })
</pre><p>This will create an inner shadow effect.</p>
<center> <div class="image">
<img src="filter_mask.png" alt=""/>
</div>
 </center><dl class="section since"><dt>Since</dt><dd>1.9</dd></dl>
<h2><a class="anchor" id="sec_commands_transform"></a>
Transform</h2>
<p>Apply a geometrical transformation to a buffer.</p>
<p>Right now, only <b>vertical flip</b> is implemented and available. This operation does not blend and assumes the destination buffer is empty.</p>
<pre class="fragment">transform ({ dst, op = 'vflip', src = input, oy = 0 })
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Destination buffer. Must be of the same colorspace as <em>src</em>. Must be specified. </td></tr>
    <tr><td class="paramname">op</td><td>Must be <code>'vflip'</code>. There is no other operation yet. </td></tr>
    <tr><td class="paramname">src</td><td>Source buffer to transform. </td></tr>
    <tr><td class="paramname">oy</td><td>Y offset.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><pre class="fragment">t = buffer ('alpha')
transform ({ oy = 20, dst = t })
blend ({ src = t, color = 'silver' })
blend ({ color = 'black' })
</pre><p>This will create a mirrored text effect, for a font of 50px.</p>
<center> <div class="image">
<img src="filter_transform.png" alt=""/>
</div>
 </center><dl class="section note"><dt>Note</dt><dd>Because of the meaning of <em>oy</em>, this effect probably needs to be customized for a single font size (FIXME).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.9</dd></dl>
<p>Remove color information from buffer's contents and leave only grayscale TODO: write down more information</p>
<p>Apply inverse color TODO: write down more information</p>
<h2><a class="anchor" id="sec_commands_padding_set"></a>
Padding_Set</h2>
<p>Forcily set a specific padding for this filter.</p>
<pre class="fragment">padding_set ({ l, r = [l], t = [r], b = [t] })
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>Padding on the left side in pixels. </td></tr>
    <tr><td class="paramname">r</td><td>Padding on the right side in pixels. If unset, defaults to <em>l</em>. </td></tr>
    <tr><td class="paramname">t</td><td>Padding on the top in pixels. If unset, defaults to <em>r</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Padding on the bottom in pixels. If unset, defaults to <em>t</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>All values must be &gt;= 0. When filtering 'filled' images, some values may be too high and would result in completely hiding the image.</p>
<p>It is not possible to set only one of those without forcing the others as well. A common use case will be when changing a blur size during an animation, or when applying a mask that will hide most of the (blurred) text.</p>
<p>Example (the <code>fill</code> command is used for illustration purposes): </p><pre class="fragment">fat = buffer ('alpha')
padding_set ({ l = 10, r = 20, t = 15, b = 25 })
fill ({ color = 'black' })
fill ({ color = 'darkblue', l = 2, r = 2, t = 2, b = 2 })
grow ({ 30, dst = fat })
blur ({ 40, src = fat, color = 'white' })
blend ({ color = 'darkblue' })
</pre><p>This will set the left, right, top and bottom paddings to their respective values, and some effects may look like they've been "clipped" out.</p>
<center> <div class="image">
<img src="filter_padding.png" alt=""/>
</div>
 </center><dl class="section since"><dt>Since</dt><dd>1.10 </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="footer">
  <p>
    <span class="version">EFL 1.26.99</span>
    <span class="copyright">Copyright &copy;2000-2022 <a href="http://www.enlightenment.org">enlightenment.org</a></span>
    <span class="generated">Generated @ Sat Oct 29 2022 18:10:33</span>
  </p>
</div>
</body>
</html>
