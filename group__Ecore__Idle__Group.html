<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Ecore Idle functions</title>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-110876574-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-110876574-1');
  </script>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link rel="icon" href="favicon.png" type="image/x-icon">
  <link rel="shortcut icon" href="favicon.png" type="image/x-icon">
  <link rel="icon" href="favicon.png" type="image/ico">
  <link rel="shortcut icon" href="favicon.png" type="image/ico">
  <link rel="stylesheet" type="text/css" href="e.css">
</head>
<body>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Ecore Idle functions<div class="ingroups"><a class="el" href="group__Ecore.html">Ecore</a> &raquo; <a class="el" href="group__Ecore__Main__Loop__Group.html">Ecore main loop</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The idler functionality in Ecore allows for callbacks to be called when the program isn't handling <a class="el" href="group__Ecore__Event__Group.html">events</a>, <a class="el" href="group__Ecore__Timer__Group.html">timers</a> or <a class="el" href="group__Ecore__FD__Handler__Group.html">fd handlers</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae4e7f2215a6e8cff3e2eab2582b5868e"><td class="memItemLeft" align="right" valign="top"><a id="gae4e7f2215a6e8cff3e2eab2582b5868e"></a>
typedef struct _Ecore_Factorized_Idle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#gae4e7f2215a6e8cff3e2eab2582b5868e">Ecore_Idler</a></td></tr>
<tr class="memdesc:gae4e7f2215a6e8cff3e2eab2582b5868e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for idlers. <br /></td></tr>
<tr class="separator:gae4e7f2215a6e8cff3e2eab2582b5868e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4e81cb020047be0f8f36db6d942ed3"><td class="memItemLeft" align="right" valign="top"><a id="gadc4e81cb020047be0f8f36db6d942ed3"></a>
typedef struct _Ecore_Factorized_Idle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#gadc4e81cb020047be0f8f36db6d942ed3">Ecore_Idle_Enterer</a></td></tr>
<tr class="memdesc:gadc4e81cb020047be0f8f36db6d942ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for idle enterers. <br /></td></tr>
<tr class="separator:gadc4e81cb020047be0f8f36db6d942ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa07d755d135454aa97625464aab4adf8"><td class="memItemLeft" align="right" valign="top"><a id="gaa07d755d135454aa97625464aab4adf8"></a>
typedef struct _Ecore_Factorized_Idle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#gaa07d755d135454aa97625464aab4adf8">Ecore_Idle_Exiter</a></td></tr>
<tr class="memdesc:gaa07d755d135454aa97625464aab4adf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for idle exiters. <br /></td></tr>
<tr class="separator:gaa07d755d135454aa97625464aab4adf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga048ed35688c416f1f495912a900e9297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#gae4e7f2215a6e8cff3e2eab2582b5868e">Ecore_Idler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga048ed35688c416f1f495912a900e9297">ecore_idler_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr class="memdesc:ga048ed35688c416f1f495912a900e9297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an idler handler.  <a href="group__Ecore__Idle__Group.html#ga048ed35688c416f1f495912a900e9297">More...</a><br /></td></tr>
<tr class="separator:ga048ed35688c416f1f495912a900e9297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b5ec4cc0d26179c1b5e3ee907e5d58"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#gaf7b5ec4cc0d26179c1b5e3ee907e5d58">ecore_idler_del</a> (<a class="el" href="group__Ecore__Idle__Group.html#gae4e7f2215a6e8cff3e2eab2582b5868e">Ecore_Idler</a> *idler)</td></tr>
<tr class="memdesc:gaf7b5ec4cc0d26179c1b5e3ee907e5d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an idler callback from the list to be executed.  <a href="group__Ecore__Idle__Group.html#gaf7b5ec4cc0d26179c1b5e3ee907e5d58">More...</a><br /></td></tr>
<tr class="separator:gaf7b5ec4cc0d26179c1b5e3ee907e5d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0805b9840716bd08ae44956dba8de3e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#gadc4e81cb020047be0f8f36db6d942ed3">Ecore_Idle_Enterer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga0805b9840716bd08ae44956dba8de3e6">ecore_idle_enterer_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr class="memdesc:ga0805b9840716bd08ae44956dba8de3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an idle enterer handler.  <a href="group__Ecore__Idle__Group.html#ga0805b9840716bd08ae44956dba8de3e6">More...</a><br /></td></tr>
<tr class="separator:ga0805b9840716bd08ae44956dba8de3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa00afaecb0a5a29add3bb92f534a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#gadc4e81cb020047be0f8f36db6d942ed3">Ecore_Idle_Enterer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga6aa00afaecb0a5a29add3bb92f534a0d">ecore_idle_enterer_before_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr class="memdesc:ga6aa00afaecb0a5a29add3bb92f534a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an idle enterer handler at the start of the list so it gets called earlier than others.  <a href="group__Ecore__Idle__Group.html#ga6aa00afaecb0a5a29add3bb92f534a0d">More...</a><br /></td></tr>
<tr class="separator:ga6aa00afaecb0a5a29add3bb92f534a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1106729c49d0cd714ef58e0343470c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga7e1106729c49d0cd714ef58e0343470c">ecore_idle_enterer_del</a> (<a class="el" href="group__Ecore__Idle__Group.html#gadc4e81cb020047be0f8f36db6d942ed3">Ecore_Idle_Enterer</a> *idle_enterer)</td></tr>
<tr class="memdesc:ga7e1106729c49d0cd714ef58e0343470c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an idle enterer callback.  <a href="group__Ecore__Idle__Group.html#ga7e1106729c49d0cd714ef58e0343470c">More...</a><br /></td></tr>
<tr class="separator:ga7e1106729c49d0cd714ef58e0343470c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bbd02660dd2b36a2da262a9bda3dfb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#gaa07d755d135454aa97625464aab4adf8">Ecore_Idle_Exiter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga4bbd02660dd2b36a2da262a9bda3dfb4">ecore_idle_exiter_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr class="memdesc:ga4bbd02660dd2b36a2da262a9bda3dfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an idle exiter handler.  <a href="group__Ecore__Idle__Group.html#ga4bbd02660dd2b36a2da262a9bda3dfb4">More...</a><br /></td></tr>
<tr class="separator:ga4bbd02660dd2b36a2da262a9bda3dfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b7d6e94230fcbc331258f7aedf6010"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga89b7d6e94230fcbc331258f7aedf6010">ecore_idle_exiter_del</a> (<a class="el" href="group__Ecore__Idle__Group.html#gaa07d755d135454aa97625464aab4adf8">Ecore_Idle_Exiter</a> *idle_exiter)</td></tr>
<tr class="memdesc:ga89b7d6e94230fcbc331258f7aedf6010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an idle exiter handler from the list to be run on exiting idle state.  <a href="group__Ecore__Idle__Group.html#ga89b7d6e94230fcbc331258f7aedf6010">More...</a><br /></td></tr>
<tr class="separator:ga89b7d6e94230fcbc331258f7aedf6010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The idler functionality in Ecore allows for callbacks to be called when the program isn't handling <a class="el" href="group__Ecore__Event__Group.html">events</a>, <a class="el" href="group__Ecore__Timer__Group.html">timers</a> or <a class="el" href="group__Ecore__FD__Handler__Group.html">fd handlers</a>. </p>
<p>There are three types of idlers: Enterers, Idlers(proper) and Exiters. They are called, respectively, when the program is about to enter an idle state, when the program is in an idle state and when the program has just left an idle state and will begin processing <a class="el" href="group__Ecore__Event__Group.html">events</a>, <a class="el" href="group__Ecore__Timer__Group.html">timers</a> or <a class="el" href="group__Ecore__FD__Handler__Group.html">fd handlers</a>.</p>
<p>Enterer callbacks are good for updating your program's state, if it has a state engine. Once all of the enterer handlers are called, the program will enter a "sleeping" state.</p>
<p>Idler callbacks are called when the main loop has called all enterer handlers. They are useful for interfaces that require polling and timers would be too slow to use.</p>
<p>Exiter callbacks are called when the main loop wakes up from an idle state.</p>
<p>If no idler callbacks are specified, then the process literally goes to sleep. Otherwise, the idler callbacks are called continuously while the loop is "idle", using as much CPU as is available to the process.</p>
<dl class="section note"><dt>Note</dt><dd>Idle state doesn't mean that the <b>program</b> is idle, but that the <b>main loop</b> is idle. It doesn't have any timers, events, fd handlers or anything else to process (which in most <em>event driven</em> programs also means that the <b>program</b> is idle too, but it's not a rule). The program itself may be doing a lot of processing in the idler, or in another thread, for example.</dd></dl>
<p>Example with functions that deal with idle state:</p>
<ul>
<li><a class="el" href="ecore_idler_example_c.html">ecore idle state - Idlers, enterers and exiters</a> </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga048ed35688c416f1f495912a900e9297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga048ed35688c416f1f495912a900e9297">&#9670;&nbsp;</a></span>ecore_idler_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#gae4e7f2215a6e8cff3e2eab2582b5868e">Ecore_Idler</a>* ecore_idler_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an idler handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call when idling. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be passed to this <code>func</code> call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A idler handle if successfully added, <code>NULL</code> otherwise.</dd></dl>
<p>Add an idler handle to the event loop, returning a handle on success and <code>NULL</code> otherwise. The function <code>func</code> will be called repeatedly while no other events are ready to be processed, as long as it returns <code>1</code> (or <code>ECORE_CALLBACK_RENEW</code>). A return of <code>0</code> (or <code>ECORE_CALLBACK_CANCEL</code>) deletes the idler.</p>
<p>Idlers are useful for progressively processing data without blocking. </p>

</div>
</div>
<a id="gaf7b5ec4cc0d26179c1b5e3ee907e5d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7b5ec4cc0d26179c1b5e3ee907e5d58">&#9670;&nbsp;</a></span>ecore_idler_del()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ecore_idler_del </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Idle__Group.html#gae4e7f2215a6e8cff3e2eab2582b5868e">Ecore_Idler</a> *&#160;</td>
          <td class="paramname"><em>idler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes an idler callback from the list to be executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idler</td><td>The handle of the idler callback to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data pointer passed to the idler callback on success, <code>NULL</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga0805b9840716bd08ae44956dba8de3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0805b9840716bd08ae44956dba8de3e6">&#9670;&nbsp;</a></span>ecore_idle_enterer_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#gadc4e81cb020047be0f8f36db6d942ed3">Ecore_Idle_Enterer</a>* ecore_idle_enterer_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an idle enterer handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call when entering an idle state. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be passed to the <code>func</code> call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the idle enterer callback if successful. Otherwise, <code>NULL</code> is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function func will be called every time the main loop is entering idle state, as long as it returns <code>1</code> (or <code>ECORE_CALLBACK_RENEW</code>). A return of <code>0</code> (or <code>ECORE_CALLBACK_CANCEL</code>) deletes the idle enterer. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Ecore__Evas__Group.html#ga32ddbb6457033ad435a177eb0c4fe235">ecore_evas_init()</a>, <a class="el" href="group__Eldbus__Basic.html#gaf405114e35fec59c14cef2203e9debd5">eldbus_name_owner_changed_callback_add()</a>, and <a class="el" href="group__Eldbus__Service.html#ga51cfeabdb75e0f0413bb398f12769f67">eldbus_service_property_changed()</a>.</p>

</div>
</div>
<a id="ga6aa00afaecb0a5a29add3bb92f534a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa00afaecb0a5a29add3bb92f534a0d">&#9670;&nbsp;</a></span>ecore_idle_enterer_before_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#gadc4e81cb020047be0f8f36db6d942ed3">Ecore_Idle_Enterer</a>* ecore_idle_enterer_before_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an idle enterer handler at the start of the list so it gets called earlier than others. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call when entering an idle state. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be passed to the <code>func</code> call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the idle enterer callback if successful. Otherwise, <code>NULL</code> is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function func will be called every time the main loop is entering idle state, as long as it returns <code>1</code> (or <code>ECORE_CALLBACK_RENEW</code>). A return of <code>0</code> (or <code>ECORE_CALLBACK_CANCEL</code>) deletes the idle enterer. </dd></dl>

</div>
</div>
<a id="ga7e1106729c49d0cd714ef58e0343470c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e1106729c49d0cd714ef58e0343470c">&#9670;&nbsp;</a></span>ecore_idle_enterer_del()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ecore_idle_enterer_del </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Idle__Group.html#gadc4e81cb020047be0f8f36db6d942ed3">Ecore_Idle_Enterer</a> *&#160;</td>
          <td class="paramname"><em>idle_enterer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes an idle enterer callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idle_enterer</td><td>The idle enterer to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data pointer passed to the idler enterer callback on success. <code>NULL</code> otherwise. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Ecore__Evas__Group.html#gab8fa311077f749190c9b622f672b2214">ecore_evas_shutdown()</a>, <a class="el" href="group__Eldbus__Basic.html#gac3c3b6f6b54ed74cfd7cd9b0ab5cfde1">eldbus_name_owner_changed_callback_del()</a>, and <a class="el" href="group__Eldbus__Service.html#ga9ebf1302c3be4a23011477b6a2f1ae65">eldbus_service_object_manager_attach()</a>.</p>

</div>
</div>
<a id="ga4bbd02660dd2b36a2da262a9bda3dfb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bbd02660dd2b36a2da262a9bda3dfb4">&#9670;&nbsp;</a></span>ecore_idle_exiter_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#gaa07d755d135454aa97625464aab4adf8">Ecore_Idle_Exiter</a>* ecore_idle_exiter_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an idle exiter handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call when exiting an idle state. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be passed to the <code>func</code> call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the idle exiter callback on success. <code>NULL</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function func will be called every time the main loop is exiting idle state, as long as it returns <code>1</code> (or <code>ECORE_CALLBACK_RENEW</code>). A return of <code>0</code> (or <code>ECORE_CALLBACK_CANCEL</code>) deletes the idle exiter. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Ecore__Evas__Group.html#ga32ddbb6457033ad435a177eb0c4fe235">ecore_evas_init()</a>.</p>

</div>
</div>
<a id="ga89b7d6e94230fcbc331258f7aedf6010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89b7d6e94230fcbc331258f7aedf6010">&#9670;&nbsp;</a></span>ecore_idle_exiter_del()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ecore_idle_exiter_del </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Idle__Group.html#gaa07d755d135454aa97625464aab4adf8">Ecore_Idle_Exiter</a> *&#160;</td>
          <td class="paramname"><em>idle_exiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes an idle exiter handler from the list to be run on exiting idle state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idle_exiter</td><td>The idle exiter to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data pointer that was being being passed to the handler if successful. <code>NULL</code> otherwise. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Ecore__Evas__Group.html#gab8fa311077f749190c9b622f672b2214">ecore_evas_shutdown()</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="footer">
  <p>
    <span class="version">EFL 1.26.99</span>
    <span class="copyright">Copyright &copy;2000-2022 <a href="http://www.enlightenment.org">enlightenment.org</a></span>
    <span class="generated">Generated @ Sat Oct 29 2022 18:10:49</span>
  </p>
</div>
</body>
</html>
